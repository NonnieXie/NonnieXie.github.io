[{"title":"04_Qt信号与槽","date":"2020-08-26T16:16:16.979Z","path":"article/20200827.html","text":"当某个事件发生之后,比如,按钮检测到自己被点击了一下,它就会发出一个信号signal。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣 ，它就会使用连接connect函数,意思是,将想要 处理的信号和自己的一个函数为槽slot绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。 一、信号和槽1.1、Qt5的书写方式123456connect(&amp;b1,&amp;QPushButton::pressed,this,&amp;Widget::close);&#x2F;* &amp;b1:信号发出者，指针类型 * &amp;QPushButton::pressed：处理的信号， &amp;发出者的类名::信号名字 * this:信号接受者 * &amp;Widget::close:槽函数，信号处理函数 &amp;发出者的类名::信号名字 *&#x2F; 1.1.1、处理子窗口的信号不带参数 注意这样会产生二义性 12connect(&amp;subWin,&amp;SubWideget::mySignal,this,&amp;Widget::dealSub);connect(&amp;subWin,&amp;SubWideget::mySignal,this,&amp;Widget::dealSlot); 1.1.2、处理子窗口的信号带参数(使用函数指针)12345void (SubWideget::*funSignal)() &#x3D; &amp;SubWideget::mySignal;connect(&amp;subWin,funSignal,this,&amp;Widget::dealSub);void(SubWideget::*testSignal)(int,QString) &#x3D; &amp;SubWideget::mySignal;connect(&amp;subWin,testSignal,this,&amp;Widget::dealSlot); 1.2、Qt4的书写方式 Qt4信号连接: 使用了LSIGNAL和TSLOT这两个宏，将两个函数名转换成了字符串。 不方便检查错误 格式：connect(信号的发出者(指针类型), 处理的信号(SIGNAL(信号名字)), 信号的接受者， 信号处理的函数(SLOT(槽函数))); 12connect(&amp;subWin,SIGNAL(mySignal()),this,SLOT(dealSub())); &#x2F;&#x2F;不带参数connect(&amp;subWin,SIGNAL(mySignal(int,QString)),this,SLOT(dealSlot(int,QString))); &#x2F;&#x2F;带参数 1.3、Lambda表达式(匿名函数对象)C++11中添加的新特性，需要在项目文件.pro中添加：CONFIG += C++11在Qt中配合信号一起使用，非常方便1.3.1、 不带参数 12345678910111213141516QPushButton *b4 &#x3D; new QPushButton(this);b4-&gt;setText(&quot;Lambda表达式&quot;);b4-&gt;move(400,300);int a &#x3D;10,b&#x3D;100;connect(b4,&amp;QPushButton::released, &#x2F;&#x2F;[]里面可以传一个变量也可以传多个变量 [b4,a,b] &#x2F;&#x2F;&#x3D;:把外部所有的局部变量、类中所有成员以值传递方式 &#x2F;&#x2F;this :类中所有成员以值传递方式 &#x2F;&#x2F;&amp;：把外部所有局部变量，引用符号 [&#x3D;]() &#123; b4-&gt;setText(&quot;123&quot;); qDebug()&lt;&lt;&quot;你好&quot;; qDebug()&lt;&lt;a&lt;&lt;b; &#125; ); 1.3.2、 带参数 12345678connect(b4,&amp;QPushButton::clicked, [&#x3D;](bool isCheck) &#123; qDebug()&lt;&lt;isCheck; qDebug()&lt;&lt;a&lt;&lt;b; &#125; ); 二、自定义信号槽2.1、信号 信号必须有singnals关键字来声明 信号没有返回值，但可以有参数 信号就是函数的声明，只需声明，无需定义 使用emit在恰当的位置发信号 信号可以重载 123signals: void mySignal(); void mySignal(int,QString);&#x2F;&#x2F;QString是Qt中的字符串 2.2、槽 槽函数是普通函数，作为成员函数，会受到public,private,protected的影响 槽函数需要和信号一致(参数和返回值) 由于信号没有返回值，则槽函数也没有返回值 任意成员函数，普通全局函数，静态函数，Lambda表达式都可以作为槽函数","tags":[{"name":"Qt","slug":"Qt","permalink":"https://nonniexie.github.io/tags/Qt/"}]},{"title":"03_Qt软件打包与发布(windeployqt工具）","date":"2020-08-26T15:39:10.643Z","path":"article/20200826.html","text":"使用官方自带的windeployqt工具来打包我们的项目。 一、查看windeloyqt工具在哪我的Qt安装在D盘，所以我知道到的目录在D:\\Qt\\Qt5.8.0\\5.8\\mingw53_32\\bin 二、生成项目的release文件打开你的项目，选择release版本，点击运行，就能够生成项目的release版本的可执行程序了。 三、打开Qt的控制台，打包 注意是Qt的控制台，不是dos界面。 将你生成的Release版的可执行程序移动到一个新的文件夹中，切换到当前的目录下，接下来使用windeployqt 程序名命令，就可以对程序进行打包操作，如图：","tags":[{"name":"Qt","slug":"Qt","permalink":"https://nonniexie.github.io/tags/Qt/"}]},{"title":"02_Qt常用的控件_QLineEdit(单行文本编辑器)","date":"2020-07-19T16:55:56.627Z","path":"article/20200720.html","text":"一、QLineEditQlineEdit为Qt的单行文本编辑器。 1.1、设置获取内容 获取编辑器框内容使用text()12QString str &#x3D;ui-&gt;lineEdit-&gt;text();qDebug()&lt;&lt;str; 设置编辑框内容使用setText()1ui-&gt;lineEdit-&gt;setText(&quot;123&quot;); 1.2、设置内容显示的间隔我们在使用QLineEdit显示文本的时候，希望在左侧流出一些空白位置，这个时候就需要我们使用QLineEdit提供的setTextMargins函数：函数声明：void QLineEdit::setTextMargins(int left, int top, int right, int bottom)此函数可以指定显示的文本与输入框上下左右边界的像素数1ui-&gt;lineEdit-&gt;setTextMargins(15,0,0,0); &#x2F;&#x2F;这里的间距是以像素点为单位 1.3、设置显示的模式我们使用QLineEdit类的setEchoMode()函数来进行设置文本的显示模式，函数的声明：void setEchoMode(EchoMode)EchoMode是一个枚举类型,一共定义了四种显示模式: QLineEdit::Normal 模式显示方式，按照输入的内容显示。 QLineEdit::NoEcho 不显示任何内容，此模式下无法看到用户的输入。 QLineEdit::Password 密码模式，输入的字符会根据平台转换为特殊字符。 QLineEdit::PasswordEchoOnEdit 编辑时显示字符否则显示字符作为密码。 12345ui-&gt;lineEdit-&gt;setEchoMode(QLineEdit::Password); &#96;&#96;&#96; ### 1.4、设置输入提示我们想输入一个或者几个字符，下边就会列出和我们输出的字符相匹配的字符串，QLineEdit要实现这样的功能可以使用该类的成员函数setComleter()函数来实现:&#96;void QLineEdit::setCompleter(QCompleter *c) &#96; QStringList list; //需要#include 字符串链表头文件list&lt;&lt;”Hello”&lt;&lt;”How are you!”&lt;&lt;”hehe”;QCompleter *com = new QCompleter(list,this); //需要#include com-&gt;setCaseSensitivity(Qt::CaseInsensitive);ui-&gt;lineEdit-&gt;setCompleter(com);```QCompleter类的setCaseSensitivity()函数可以设置是否区分大小写，它的参数是一个枚举类型： Qt::CaseInsensitive 不区分大小写 Qt::CaseSensitive 区分大小写 如果不设置该属性，默认匹配字符串时是区分大小写的。","tags":[{"name":"Qt","slug":"Qt","permalink":"https://nonniexie.github.io/tags/Qt/"}]},{"title":"在Ubuntu 16.04.6 LTS下使用Docker安装Oracle镜像及其简单的使用","date":"2020-07-14T16:04:46.094Z","path":"article/20200715.html","text":"确定你的Ubuntu 16.04下已经安装Docker,没有安装的话可以看我以前的文章Docker的入门。 1、查找oracle镜像1docker search oracle 2、拉取docker镜像并运行、进入1234docker pull registry.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g &#x2F;&#x2F;拉取docker镜像docker images &#x2F;&#x2F;查看镜像是否下载成功docker run -d -p 1521:1521 --name oracle registry.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g &#x2F;&#x2F;运行该镜像docker exec -it oracle &#x2F;bin&#x2F;bash &#x2F;&#x2F;进入容器 3、配置环境变量和修改账户密码 进入root账户su root,输入密码：helowin 编辑/etc/profile文件，并在文件的末尾添加下面内容 12345export ORACLE_HOME&#x3D;&#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;dbhome_2export ORACLE_SID&#x3D;helowinexport PATH&#x3D;$ORACLE_HOME&#x2F;bin:$PATHsource &#x2F;etc&#x2F;profile &#x2F;&#x2F;使修改的生效 切换oracle用户:su oracle 使用sqlplus连接到oracle:sqlplus /nolog → connect /as sysdba 修改 sys 和 system 的密码并且修改密码的有效时间为无限 123alter user system identified by oracle;alter user sys identified by oracle;ALTER PROFILE DEFAULT LIMIT PASSWORD_LIFE_TIME UNLIMITED;","tags":[{"name":"Docker","slug":"Docker","permalink":"https://nonniexie.github.io/tags/Docker/"}]},{"title":"在Ubuntu 16.04.6 LTS下使用Docker安装Ubuntu、CetOS和MySQL镜像及其简单的使用","date":"2020-07-13T17:18:38.862Z","path":"article/20200714.html","text":"确保你的系统下安装有Docker,切换到root账户下，如果是普通用户，下面的指令操作需要在指令前添加sudo. Docker的安装实例1、Docker安装Ubuntu 123456docker search ubuntu &#x2F;&#x2F;搜索ubuntu镜像docker pull ubuntu &#x2F;&#x2F;拉取最新版的 Ubuntu 镜像docker images &#x2F;&#x2F;查看本地镜像docker run -itd --name ubuntu-test ubuntu &#x2F;&#x2F;启动容器，并将容器的名字改为ubuntu-test docker exec -it ubuntu-test &#x2F;bin&#x2F;bash &#x2F;&#x2F;进入启动的容器下docker ps &#x2F;&#x2F;查看容器的运行信息 2、Docker安装CentOS123456docker search centos &#x2F;&#x2F;搜索centos 镜像docker pull centos:centos7 &#x2F;&#x2F;拉取指定版本的 CentOS 镜像，这里我们安装指定版本为例(centos7):docker images &#x2F;&#x2F;查看本地镜像docker run -itd --name centos-test centos:centos7 &#x2F;&#x2F;运行容器docker exec -it centos-test &#x2F;bin&#x2F;bashdocker ps &#x2F;&#x2F;查看容器的运行信息 3、Docker安装MySQL1234567891011121314151617181920docker search mysql &#x2F;&#x2F;查看可用的 MySQL 版本docker pull mysql:latest 拉取 MySQL 镜像docker images &#x2F;&#x2F;查看本地镜像#启动docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql&#x2F;&#x2F;参数说明： -p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。 -e MYSQL_ROOT_PASSWORD&#x3D;123456：设置 MySQL 服务 root 用户的密码。 -d 后台运行容器，并返回容器的IDdocker ps &#x2F;&#x2F;查看容器的运行信息 #进入容器docker exec -it mysql &#x2F;bin&#x2F;bash#登录mysqlmysql -u root -pALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;; 、、#添加远程登录用户CREATE USER &#39;salt&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;GRANT ALL PRIVILEGES ON *.* TO &#39;salt&#39;@&#39;%&#39;;","tags":[{"name":"Docker","slug":"Docker","permalink":"https://nonniexie.github.io/tags/Docker/"}]},{"title":"Docker的使用","date":"2020-07-12T16:06:44.365Z","path":"article/20200713.html","text":"一、Docker的使用1.1、运行Hello World在docker中可以在容器中运行应用程序,我们使用docker run命令来实现在一个容器中运行一个应用程序。 1docker run ubuntu &#x2F;bin&#x2F;echo &quot;Hello world&quot; &#x2F;&#x2F;Docker 以 ubuntu镜像创建一个新容器，然后在容器里执行 bin&#x2F;echo &quot;Hello world&quot;，然后输出结果。 2.1、运行交互式的容器我们通过使用-t -i,来让docker运行的容器实现“对话”的功能： 123456docker run -i -t ubuntu &#x2F;bin&#x2F;bash &#x2F;&#x2F;参数说明： -t 在新容器内制定一个伪终端或终端 -i 允许你的容器内的标准输入进行交互 cat &#x2F;proc&#x2F;version &#x2F;&#x2F;查看当前系统的版本信息 ls &#x2F;&#x2F;查看容器下的文件列表 3.1、启动容器(后台模式)可以使用下面命令来创建一个以进程方式运行的容器: 123456789docker run -d ubuntu &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot; &#x2F;&#x2F;运行之后我们并没有看到输入“Hello world”,而看到的是容器的ID docker ps &#x2F;&#x2F;查看确定容器是否在运行 &#x2F;&#x2F;查看容器内的标准输出 docker logs &lt;容器ID&gt; docker logs &lt;自动分配的容器名称&gt; &#x2F;&#x2F;删除一个容器docker rm -f &lt;容器 ID&gt; &#x2F;&#x2F;以清理掉所有处于终止状态的容器。 docker container prune 二、容器使用 2.1、获取镜像 docker pull ubuntu 2.2、启动容器 docker run -it ubuntu /bin/bash 2.3、后台运行 docker run -itd --name ubuntu-test ubuntu /bin/bash //设置容器名为ubuntu-test 2.3、启动已经停止的容器 12docker ps -a &#x2F;&#x2F;查看所有容器docker start &lt;容器 ID&gt; &#x2F;&#x2F;启动一个已停止的容器 2.4、停止一个容器 123456&#x2F;&#x2F;停止容器docker stop &lt;容器 ID&gt;docker stop &lt;自动分配的容器名称&gt; &#x2F;&#x2F;重启容器docker restart &lt;容器 ID&gt;docker restart &lt;自动分配的容器名称&gt; 2.5、进入后台容器 123docker ps &#x2F;&#x2F;查看运行的容器docker attach &lt;运行容器 ID&gt; or &lt;运行容器的容器名&gt; docker exec -it &lt;运行容器 ID&gt; &#x2F;bin&#x2F;bash &#x2F;&#x2F;使用exit或者ctrl +D退出，后台容器不会退出 2.6、导出和导入容器 12docker export &lt;容器 ID&gt; &gt; ubuntu.tar &#x2F;&#x2F;导出容器cat &#x2F;root&#x2F;ubuntu.tar |docker import - test&#x2F;ubuntu:v1 &#x2F;&#x2F;导入容器 2.7、查看端口的映射情况 12docker port &lt;容器ID&gt;docker port &lt;自动分配的容器名称&gt; 注意：如果你这里使用exit或者ctrl +D的话，后台运行的容器就会直接退出。推荐大家使用docker exec命令，因为此退出容器终端，不会导致容器的停止。 三、Docker镜像使用当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。 3.1、列出镜像列表在root用户下，我们可以通过使用docker images来列出本地主机上的镜像。 还可以使用以下命令: 123docker search ubuntu &#x2F;&#x2F;查找镜像docker pull ubuntu:13.10 &#x2F;&#x2F;获取新的镜像docker rmi hello-world &#x2F;&#x2F;删除镜像","tags":[{"name":"Docker","slug":"Docker","permalink":"https://nonniexie.github.io/tags/Docker/"}]},{"title":"Docker的初学和安装","date":"2020-07-12T15:36:36.727Z","path":"article/20200712.html","text":"前提：我们初学docker的话,我们需要熟悉Linux的命令和背景知识，及其git的相关知识。推荐一本书Docker基础与实战 (访问密码 : 2vfnt5) 一、Docker教程Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 1、Docker的优点Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。 2、Docker容器技术和传统虚拟机技术的性能比较 特性 容器 虚拟机 启动速度 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 隔离性 安全隔离 完全隔离 3、Docker的相关链接Docker官网：https://www.docker.com/Github Docker 源码：https://github.com/docker/docker-ce 二、Docker的安装Docker支持在主流的操作系统平台上使用，包括Ubuntu、CentOS、Windows和MacOS系统。这里我主要是Ubuntu使用来进行其他的系统安装可以参考https://www.runoob.com/docker/ubuntu-docker-install.html 2.1、使用官方安装脚本自动安装123curl -fsSL https:&#x2F;&#x2F;get.docker.com | bash -s docker --mirror Aliyun&#x2F;&#x2F;也可以使用国内 daocloud 一键安装命令curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker | sh 2.2、使用Docker仓库进行安装 选择国内的云服务商，这里选择阿里云为例 1curl -sSL http:&#x2F;&#x2F;acs-public-mirror.oss-cn-hangzhou.aliyuncs.com&#x2F;docker-engine&#x2F;internet | sh - 安装所需要的包 1sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual 添加使用 HTTPS 传输的软件包以及 CA 证书 12sudo apt-get updatesudo apt-get install apt-transport-https ca-certificates 添加GPG密钥 1sudo apt-key adv --keyserver hkp:&#x2F;&#x2F;p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D 添加软件源 1echo &quot;deb https:&#x2F;&#x2F;apt.dockerproject.org&#x2F;repo ubuntu-xenial main&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list 添加成功后更新软件包缓存 1sudo apt-get update 安装docker 1sudo apt-get install docker-engine 启动 docker 12sudo systemctl enable dockersudo systemctl start docker 测试运行 1sudo docker run hello-world 三、Docker镜像加速我们一般在DockerHub拉取镜像有时会遇到困难，此时我们就需要配置加速器。这里我使用国内加速器服务，阿里云：https://&lt;你的ID&gt;.mirror.aliyuncs.com 没有阿里云的自己去注册一个自己的阿里云账户。 针对Docker客户端版本大于 1.10.0 的用户 您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器 123456789sudo mkdir -p &#x2F;etc&#x2F;dockersudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123;&quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;nw5iareo.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart dockerdocker info &#x2F;&#x2F;&#x2F;显示 Docker 系统信息","tags":[{"name":"Docker","slug":"Docker","permalink":"https://nonniexie.github.io/tags/Docker/"}]},{"title":"开源中国Gitee Tree浏览项目目录结构","date":"2020-07-10T16:44:17.091Z","path":"article/20200711.html","text":"我们一般在访问Github和Gite时，点击需要查看项目下的目录时需要点击才能能够进行跳转。这样每次的跳转每次都需要刷新界面，并且很不方便。 使用Gitee Tree浏览器插件可以在Gitee、GitHub上显示代码树。不需要clone到本地就可以查看项目结构。特性： 就像在IDE一样简单易用的代码树 快速浏览文件，不同刷新界面 支持私有人存储库 一、拉取Gitee Tree项目登录自己的码云账号，在搜索区输入Gitee Tree来进行搜索项目。 在自己的本地建立一个文件夹进入，鼠标右键Git bash Here来进行拉取。 二、在Chrome安装在克隆下来的项目中找到dist文件夹，我的目录时C:\\Users\\Salt\\Desktop\\Gitee Tree\\GitCodeTree\\dist,自己的因人而异。解压dist下的chrome.zip压文件,打开Chome浏览器的扩展程序，进行加载已解压的扩展程序。安装完成就入下图一样： 三、显示界面使用快键键Ctrl+shift+s来快速打开左侧的代码树,展示效果如下：","tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://nonniexie.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"MySQL学习笔记","date":"2020-06-04T16:20:07.379Z","path":"article/20200605.html","text":"数据的安装和远程连接，请访问如下：https://blog.csdn.net/qq_43630810/article/details/104287280 一、MySQL命令1、MySQL操作1.1、启动和停止服务操作在命令行输入： 123service mysql start &#x2F;&#x2F;开始mysql服务service mysql stop &#x2F;&#x2F;停止mysql服务service mysql restart &#x2F;&#x2F;重新启动mysql服务 1.2、查看MySQL服务在命令行输入：ps -e|grep mysql 1.3、登录mysql数据库在命令行输入：mysql -u root -p 2、MySQL数据库操作mysql数据库操作与sql语句(对大小写不敏感) 2.1、显示已经存在的数据库123456789mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.05 sec) 2.2、创建一个新的数据库命令格式：create database 数据库的名字（DB_dbname） 12mysql&gt; create database db_test; &#x2F;&#x2F;db_test为数据库的名字Query OK, 1 row affected (0.00 sec) 2.3、使用指定的数据库命令格式:use 查看的数据名 12mysql&gt; use db_test; &#x2F;&#x2F;db_test为查看的数据库名Database changed 2.4、查看数据库中的表命令格式：show tables; 12mysql&gt; show tables;Empty set 2.5、==创建数据库表==在此说明数据记录的属性： 关键概念： 字段名：表格的列名 数据类型：该列数据的存储类型（主要有数据类型、时间日期类型和字符串类型） 数据类型 字节数(byte) int 4 float 4 tinyint 1 Bigint 8 double 8 &gt;注:int和double比较重要 时间日期类型 格式 范围 date YYYY-MM-DD 1000-01-01 ~ 9999-12-31 TIME HH:MM:SS -838:59:59 ~ 838:59:59 YEAR YYYY 1901-2155 DATETIME YYYY-MM-DD HH:MM:SS &gt;注:date和time比较重要 字符串类型 范围(byte) 名称 varchar 0-65535 变长字符串 text 0-65535 长文本数据 longtext 0-4294967295 极大文本数据 &gt;注:varchar比较重要 命令格式：create table 表名 (字段名1 数据类型, 字段名2 数据类型… 字段名n 数据类型); 12mysql&gt; create table student(id int,name varchar(20)); &#x2F;&#x2F;创建表名为studentQuery OK, 0 rows affected (0.03 sec) 创建表格时实现唯一性约束:create table 表名 (字段名1 数据类型 not NULL, 字段名2 数据类型… 字段名n 数据类型,UNIQUE (字段名1)); //not NULL非空约束，UNIQUE设置唯一例如：create table student_1(id int not NULL,name varchar(50),UNIQUE (id)); 2.6、向表中插入数据查看表结构：desccribe 表名;或者desc 表名;插入数据的语法格式： insert into 表名 values(value1, value2,..valuen); 12345678910mysql&gt; desc student;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.04 sec)mysql&gt; insert into student values(1,&#39;xiaoming&#39;);Query OK, 1 row affected (0.01 sec) 2.7、查询表中的记录语法格式：select 字段1，字段2 ..字段n from 表名 [where Clause] [Limit N]; 12345mysql&gt; select * from student; mysql&gt; select id from student;mysql&gt; select * from student where id &#x3D; 1;mysql&gt; select id 学号 from student; &#x2F;&#x2F;别名mysql&gt; select id &#39;学号&#39; from student; 2.8、删除操作 删除记录:delete from 表名 where 条件; 删除表:drop table 表名; 删除数据库:drop database 数据库名 12mysql&gt; delete from student where id&#x3D;2; &#x2F;&#x2F;删除id为2Query OK, 1 row affected (0.01 sec) 2.9、更新表中的记录命令格式： update 表名 set 字段=值，字段=值 where 条件; 123mysql&gt; update student set id &#x3D;2 where id&#x3D;1; &#x2F;&#x2F;修改id为1的修改为2Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0 2.9、==中文乱码问题==首先查看数据库编码：show variables like &#39;char%&#39;;改成utf8格式 123set charactor_set_database&#x3D;utf8;set character_set_server&#x3D;utf8;alter database 数据库名 default character set utf8 collate utf8_general_ci; 注：想要实现中文不乱码，输入以上三行，重新建立表格，而之前的表格是无法再改为中文的。 2.10、过滤重复在查询语句中使用distinct关键字来过滤重复的行。命令格式：select distinct * from 表名; 二、SQL约束用于规定数据表中的数据使用规则。如果存在违反约束规则，数据行为就会被约束终止 2.1、约束条件1.1.1、NOT NULL 非空约束 规定该数据段不能为空 创建时候的非空约束CREATE TABLE Student(ID int not NULL, Name varchar(50) not NULL, Age int); 为表中的Age字段添加非空约束ALTER TABLE Student MODIFY Age int NOT NULL; 删除表中的Age字段的非空约束ALTER TABLE Student MODIFY Age int NULL; 1.1.2、UNIQUE 保证某列的每行必须有唯一的值 创建时候的唯一约束CREATE TABLE Student( ID int NOT NULL, Name varchar(50) NOT NULL, Age int,UNIQUE (ID)); 一个字段的唯一约束： 删除表中ID字段的唯一约束ALTER TABLE Student DROP INDEX ID; 添加表中ID字段的唯一约束ALTER TABLE Student ADD UNIQUE (ID); 多个字段的唯一约束： 添加表中ID和Name字段的唯一约束ALTER TABLE Student ADD CONSTRAINT StuID UNIQUE (ID,Name); 删除表中ID和Name字段的唯一约束ALTER TABLE Student DROP INDEX StuID ; 注：如果设置了两个字段都是非空约束和唯一约束，则相当于这两个字段都是主键，则其中第二个字段的设置就失效了。 1.1.3、PRIMARY KEY主键约束实际上可以理解为UNIQUE和NOT NULL 的结合 唯一的标准数据库中的每一条记录 主键必须包含唯一的值 主键列中不能有包含NULL的值 每个表都应该有一个主键，并且每一个表只能有一个主键 创建表时添加主键：create table Student( ID int NOT NULL, Name varchar(50) NOT NULL, Age int, PRIMARY KEY (ID)); 当表已经创建时，再设置主键约束 删除主键:ALTER TABLE Student DROP PRIMARY KEY; 添加主键:ALTER TABLE Student ADD PRIMARY KEY (ID); 1.1.4、FOREIGN KEY 外键约束保证一个表中的数据匹配另一个表中的值的参照完整性,一个表中外键指向了另一个表中的主键（唯一约束） 外键的优势: 外键约束预防破坏表与表之间的行为 也能防止非法数据的插入，因为外键中的内容是指向表中的值之一 删除表中的外键约束:ALTER TABLE Orders DROP FOREIGN KEY fk_Orders; 撤销数据库中所有表的外键约束(不常用):SET FOREIGN_KEY_CHECKS=0;之前建立的表的外键约束都无发修改了，之后的设置都可以撤销了外键约束 添加表中的外键约束: ALTER TABLE Orders ADD CONSTRAINT fk_Orders FOREIGN KEY (S_id) REFERENCES Student(ID); 三、多表联合查询 首先建立两个表：建立两个表:表1 tcount_tbl(网站点击次数) :create table tcount_tbl(id int,website varcahr(20)); website count baidu 26 bilibili 35 bilibili 35 github 10 表2 info_tbl(网站上教授的内容) :create table info_tbl(id int,title varcahr(20),website varcahr(20)); id title website 1 c++ baidu 2 Linux bilibili 3 C bilibili 4 python github 5 java Google 内连接：查询两个表中相交的内容 需要连接两张表进行联合查询，读取info_tbl表中所有website字段在tcount_tbl表中对应的count字段值，将info_tbl 作为a， tcount_tbl作为b 12345678910mysql&gt; SELECT a.id,a.website,b.count FROM info_tbl a INNER JOIN tcount_tbl b ON a.website &#x3D; b.websit;+----+----------+-------+| id | website | count |+----+----------+-------+| 1 | baidu | 26 || 2 | bilibili | 35 || 3 | bilibili | 35 || 4 | github | 10 |+----+----------+-------+4 rows in set (0.05 sec) 左连接会读取a表中的所有内容，即使b表没有对应数据1234567891011mysql&gt; SELECT a.id,a.website,b.count FROM info_tbl a LEFT JOIN tcount_tbl b ON a.website &#x3D; b.websit;+----+----------+-------+| id | website | count |+----+----------+-------+| 1 | baidu | 26 || 2 | bilibili | 35 || 3 | bilibili | 35 || 4 | github | 10 || 5 | Google | NULL |+----+----------+-------+5 rows in set (0.03 sec) 右连接会读取b表中的所有内容，即使a表中没有对应数据1234567891011mysql&gt; SELECT a.id,a.website,b.count FROM info_tbl a RIGHT JOIN tcount_tbl b ON a.website &#x3D; b.websit;+------+----------+-------+| id | website | count |+------+----------+-------+| 1 | baidu | 26 || 2 | bilibili | 35 || 3 | bilibili | 35 || NULL | NULL | 16 || 4 | github | 10 |+------+----------+-------+5 rows in set (0.05 sec)","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://nonniexie.github.io/tags/MySQL/"}]},{"title":"01_Qt应用程序框架和常用的快捷键","date":"2020-06-02T14:13:26.009Z","path":"article/20200602.html","text":"三、Qt应用程序框架 注意：在用别人的代码时，需要删除项目代码中的*.pro.user文件。此文件是保存，项目的的构建目录每一个人使用的项目构建路径不一样 3.1、项目.pro文件1234567891011121314151617#模版QT +&#x3D; core gui#高于4版本，添加QT+&#x3D;widgets,为了兼容Qt4greaterThan(QT_MAJOR_VERSION, 4): QT +&#x3D; widgets#应用程序的名字TARGET &#x3D; make#指定mekefile的类型，appTEMPLATE &#x3D; app#源文件 .cpp文件SOURCES +&#x3D; main.cpp\\ mywidget.cpp#头文件 .h文件HEADERS +&#x3D; mywidget.h 3.2、main.cpp主函数123456789101112131415161718192021222324#include &quot;mywidget.h&quot;&#x2F;&#x2F;QApplication应用程序类&#x2F;&#x2F;Qt头文件没有.h&#x2F;&#x2F;头文件和类名一样#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; &#x2F;&#x2F;有且只有一个应用程序类的对象 QApplication a(argc, argv); &#x2F;&#x2F;MyWidget继承与QWindget,QWidget是一个窗口基类 &#x2F;&#x2F;所以MyWidget也是窗口基类 &#x2F;&#x2F;w就是一个窗口 MyWidget w; &#x2F;&#x2F;窗口穿件默认是隐藏，需要人为显示 w.show(); &#x2F;&#x2F;让程序一直执行，等待用户操作 &#x2F;&#x2F;等待时间的发生 return a.exec();&#125; 二、常用的快捷键 帮助文件：F1 （光标在函数名字或类名上，按 F1 即可跳转到对应帮助文档，查看其详细用法） .h 文件和对应.cpp 文件切换：F4 编译并运行：Ctrl + R 函数声明和定义(函数调用和定义)切换：F2 代码注释取消注释：Ctrl + /（选中代码再按快捷键） 字体变大变小：Ctrl + 鼠标滚轮向上向下 移动代码：选中所要移动的代码 -&gt; 按住 ctrl + shift -&gt; 键盘方向键 查找替换关键字：ctrl + f 快速打开代码所在目录：编辑模式下 -&gt; 选中项目文件 -&gt; 右击 -&gt; 选择“显示包含的目录”，即可显示项目所在目录（此方法同样可以打开代码文件所在目录） 三、制作好看的图标QT是跨平台的程序设计库，程序往往想要有一个好看的图标，方法如下： 准备个ICO图标。例如：first.ico 在.pro文件（项目文件）里写：RC_ICONS = first.ico 保存，重新编译程序","tags":[{"name":"Qt","slug":"Qt","permalink":"https://nonniexie.github.io/tags/Qt/"}]},{"title":"使用Typecho搭建个人网站","date":"2020-05-04T16:40:33.546Z","path":"article/20200505.html","text":"博主以前是Hexo和GitHub来搭建的网站nonniexie.cn的,这里介绍用Typecho来搭建。准备工作，需要一台自己的云服务器。并且远程连接到云服务器上，给你推荐几个比较好用的连接工具FinalShell、Xshell 5、SecureCRTP、putty一共四款工具。个人比较喜欢Xshell 5和FillalShell。 一、安装宝塔面板 首先远程连接云服务器 在命令行输入: Centos安装脚本 1yum install -y wget &amp;&amp; wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install_6.0.sh &amp;&amp; sh install.sh Ubuntu/Deepin安装脚本 1wget -O install.sh http:&#x2F;&#x2F;download.bt.cn&#x2F;install&#x2F;install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh 注意安装完成后的地址、用户名和密码。如果登录不上，去放开端下面端口 123456Bt-Panel: http:&#x2F;&#x2F;49.232.136.20:8888&#x2F;05e1fe2dusername: ts75d74opassword: d170b182Warning:If you cannot access the panel, release the following port (8888|888|80|443|20|21) in the security group 成功登录到宝塔面板 根据提示安装Nginx、Mysql、php 二、搭建基于Typecho的网站 下载Typecho包 http://typecho.org/download 寻找自己喜欢的模版https://typecho.me/ 在宝塔面板点击【网站】，然后添加站点 在宝塔面板上点击【文件】，在创建网站的根目录下上传下载好的Typecho包和主题 注意：将Typecho包里面的文件拷贝到网站根目录下，而主题则在Typecho包里面的user下的themes里面 在浏览器输入域名，进行安装Typecho和配置网站 接下面的操作，参考主题的配置几乎都有的","tags":[]},{"title":"gdb调试的使用","date":"2020-05-03T08:05:31.098Z","path":"article/20200503.html","text":"gdb GDB（GNU Debugger）是GCC的调试工具。 一、生成调试的可执行文件一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（gcc/g++）的 -g 参数可以做到这一点。如： gcc -g hello.c -o hello g++ -g hello.cpp -o hello 如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。 二、启动gdb gdb 可执行程序三、查看源代码list命令来打印程序的源代码，默认打印10行。list简写为l l 行号(函数名)l filename:行号(函数名) 四、设置断点break 设置断点，可以简写为b 4.1、设置当前文件断点： b 行号(函数名) 4.2、设置指定文件断点 b filename:行号(函数名) 4.3、设置条件断点 b 文件名:行数 if 变量名 = 值 4.4、删除断点 delete 设置断点，可以简写为d d 断点的编号获取编号：info break 简写(i b) 五、查看设置的断点 info break 简写(i b) 六、开始 执行gdb调试 执行一步操作：start 执行多步，直接停在断点处：c —- continue —-直接停在断点位置 七、单步调试7.1、进入函数体内部： s —- step(单步）—-可以进入函数体内部 从函数体中跳过：finish 7.2、不进入函数体内部： n —- next(单步) —-跳过此函数体内部 退出当前循环： until，可以简写为u 八、查看运行时的数据-print 打印变量、字符串、表达式等的值，可简写为p p 变量名 九、查看变量的类型 ptype 变量名 十、设置变量的值 set var 变量名=赋值 十一、追踪变量 设置追踪变量 display 变量 取消追踪变量 undisplay 编号获取编号：info display 十二、退出gdb调试 quit","tags":[{"name":"Linux","slug":"Linux","permalink":"https://nonniexie.github.io/tags/Linux/"}]},{"title":"一篇文章弄明白Wireshark抓包工具的用法","date":"2020-04-15T16:53:12.015Z","path":"article/20200416.html","text":"wireshark网络抓包工具Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。网络封包分析软件的功能可想像成 “电工技师使用电表来量测电流、电压、电阻” 的工作 - 只是将场景移植到网络上，并将电线替换成网络线。 wireshark的官方下载地址：https://www.wireshark.org/download.html wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，从而显示网络封包的详细信息。 Wireshark不能做wireshark不能够修改封包的内容或者发送封包，只能够只来查看封包。 wireshark开始进行抓包wireshark开始界面wiershark是用来捕捉电脑上的某一个网卡的网络包，而电脑上具有多个网卡的时候就需要进行从着多个网卡中选择，你需要的一个网卡。 wireshark窗口介绍WireShark 主要分为这几个界面 Display Filter(显示过滤器)， 用于过滤 Packet List Pane(封包列表)， 显示捕获到的封包， 有源地址和目标地址，端口号。 颜色不同，代表 Packet Details Pane(封包详细信息), 显示封包中的字段 Dissector Pane(16进制数据) Miscellanous(地址栏，杂项) wireshark显示过滤使用显示过滤的原因，在我们者初次使用wireshark时，将会产生大量的冗余数据，想想这么多的数据让我们在其中找到我们需要的部分，这样就显得非常的难。相对而言过滤器就会在大量的数据中能够让我们从中找到我们所需要的数据信息。过滤器有两种： 显示过滤器，就是主界面上那个，用于在捕获的记录中找到所需要的记录 捕获过滤器：用来过滤捕获的封 包，以避免捕获的太多记录。在捕获→捕获过滤器 过滤表达式的规则 协议过滤TCP 只显示TCP协议。 IP 过滤 12ip.src ==192.168.1.102 显示源地址为192.168.1.102ip.dst==192.168.1.102 目标地址为192.168.1.102 端口过滤 12tcp.port &#x3D;&#x3D; 80 端口为80的 tcp.srcport &#x3D;&#x3D; 80 只显示TCP协议的愿端口为80的。 Http模式过滤 12http.request.method&#x3D;&#x3D;&quot;GET&quot; 只显示HTTP GET方法的。request.method&#x3D;&#x3D;&quot;GET&quot; 只显示HTTP GET方法的。 逻辑运算符为 AND/ OR","tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://nonniexie.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"Git的安装与使用","date":"2019-07-19T16:45:07.193Z","path":"article/20190720.html","text":"说明：此文章是学习黑马程序员Git零基础入门到实战详解整理的笔记，主要是Windowns下Git的安装、基本使用、分支管理、版本回退、冲突解决、GUI工具的介绍、文件忽略机制等。如想在Linux平台下安装Git 查看通过https://blog.csdn.net/qq_43630810/article/details/104483007来进行安装。 一、Git基础Git是目前世界上最先进的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 1、谈谈Git与SVN的区别 Git是分布式的，svn是集中式的：这个是Git和其他非分布式的版本控制系统的，最主要的区别。 Git把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn、.git的文件中 Gitf分支和SVN的分支不同：分支在SVN中一点都不特别，其实它就是版本库中的另一个目录 Git没有一个全局的版本号，而SVN有：目前为止这是SVN相比Git缺少最大的一个特征 Git的内容完整性要优于SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。2、SVN的弊端与Git的好处 SVN弊端：1、中央服务器坏了，一切OVER2、所有的上传和下载都是基于文件传输方式完成的，速度会慢 git好处1、无需连网也能记录查看历史版本信息2、无需过多依赖中央仓库，每个人本地也有全部的信息向中央仓库传输内容依托的是文件流传输，速度比SVN块N倍 3、Git与GitHubGit的安装与GithHub账户的注册不做介绍。1 、两者区别Git(https://git-scm.com/)是一个分布式版本控制系统，简单的说其就是一个软件，用于记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的软件。 Github（https://www.github.com）是一个为用户提供Git服务的网站，简单说就是一个可以放代码的地方（不过可以放的当然不仅是代码）。Github除了提供管理Git的web界面外，还提供了订阅、关注、讨论组、在线编辑器等丰富的功能。Github被称之为全球最大的基友网站。 二、Git的使用过程1、本地仓库1.1、工作流程Git本地操作分为三个区域： 工作流程： 工作流程： 1.2、本地仓库操作什么是仓库呢？仓库又名版本库，英文名repository，我们可以简单理解成是一个目录，用于存放代码的，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除等操作Git都能跟踪到。 ①在安装好后首次使用我们需要进行全局配置在桌面空白处右键，点击“Git Bash Here” 已打开Git命令行窗口 123$ git config --global user.name \"用户名\"$ git config --global user.email \"邮箱地址\"$ git config --list 注意：配置完成后输入git config –global user.name和git config –global user.email进行查看，是否是自己所绑定的。 ②创建仓库当我们需要让Git去管理某个项目的时候，就需要创建仓库了。在创建仓库时使用的目录不一定要求是非空的目录，但是最好使用一个非空的目录。 注意：在使用过程中最好不要使用包含中文的目录名（目录亦是如此）。 a、创建空目录：mkdir pro_gitb、进入项目目录中：cd pro_gitc、Git仓库初始化：（让Git知道，它需要来管理这几个目录） 指令：git init③Git常用指令操作查看当前状态：git status 【非必要】添加到缓存区：git add 文件名 1234说明：git add指令，可以添加一个文件，也可以同时添加多个文件。语法1：git add 文件名语法2：git add 文件名1 文件名2 文件名3 …语法3：git add . 【添加当前目录到缓存区中】 提交至版本库：git commit -m “注释内容” 1.3、版本回退版本回退分为两步骤进行操作： 12345678步骤： ①查看版本，确定需要回到的时刻点 指令： git log git log --pretty=oneline ②回退操作 指令： git reset --hard 提交编号 案例：查看版本和回退到创建第一个文件readme.txt的版本。 注意:回退到过去的版本，要想在回到之间最新的版本的时候。可以通过之间查看的的提交码回到最新版本，也可以使用(git reflog)指令去查看历史操作，以得到最新的commit ID。 2、远程仓库主要以GitHub为例。 2.1、GithHub创建打开创建仓库页面：https://github.com/new圈出的部分为必填项，其余根据实际需要选择性补充： 注意：仓库名要在当前用户下唯一。 2.2 、两种不同的使用方式2.2.1、基于http/https协议a、创建空目录，名称为shopb、使用clone指令克隆线上仓库到本地语法：git clone 线上仓库 c、在仓库上做对应的操作（提交暂存区、提交本地仓库、提交线上仓库、拉取线上仓库）提交到线上仓库的指令：git push拉取线上仓库：git pull 提醒：在以后每天工作中第一件事就是先git pull拉取线上最新的版本；而下班前要做的是git push，将本地的代码提交到线上仓库。 2.2.2、基于ssh协议（推荐）该方式与前面https方式相比，此方式影响github对于用户的身份鉴权方式，对于git的具体操作（如提交本地、添加注释、提交远程等操作）没有任何影响。 ①生成公私玥对指令（需先OpenSSH安装，若是没有联系我）：ssh-keygen -t rsa -C “注册邮箱”②上传公钥内容（id_rsa.pub）③执行后续git的操作a、clone线上仓库到本地（git clone）b、修改文件后添加缓存区、提交本地仓库、提交线上仓库在git push的时候并没有提示要求我们输入帐号密码，说明公私玥已经实现了用户身份鉴权。 2.3、分支管理什么是分支？ 在版本回退中，每次提交后都会有记录，Git把它们串成时间线，形成类似于时间轴的东西，这个时间轴就是一个分支，我们称之为==master分支==。 而在开发的时候往往是团队协作，多人进行开发，因此光有一个分支是无法满足多人同时开发的需求的，并且在分支上工作并不影响其他分支的正常使用，会更加安全，Git鼓励开发者使用分支去完成一些开发任务。 123456分支相关指令：查看分支：git branch创建分支：git branch 分支名切换分支：git checkout 分支名 删除分支：git branch -d 分支名合并分支：git merge 被合并的分支名 查看分支： 注意：当前分支前面有个标记“*”； 创建分支：切换分支：合并分支：现在先将dev分支下的readme文件中添加一行并提交到本地切换到master分支下观察readme文件的内容将dev分支的内容和master分支合并：删除分支： 注意：在删除分支的时候，一定要先退出要删除的分支，然后才能删除。 合并所有分支之后，需要将master分支提交线上远程仓库中： 2.4、冲突的产生与解决案例：模拟产生冲突。①下班之后同事在线上仓库进行修改 注意：此时我的本地仓库的内容和线上不一致的。 ②第二天上班的时候，没有拉取线（git pull）上的文件，而直接修改了本地所对应的文件内容。③在下班的时候将文件推送到线上仓库（git push） 提示我们要在再次push之间先git pull操作。 ==【解决冲突】==④先git pull⑤打开冲突文件，解决冲突解决方法：需要和同事进行商量，看代码如何保留，然后将改好的文件再次提交即可。⑥重新提交⑦查看线上效果 新手小技巧：上班第一件事先git pull,可以在一定程度上避免冲突的产生。 三、实用技能1、图形管理工具1.1、GitHub for DektopGithub出品的软件，功能完善，使用方便。对于经常使用GitHub的开发人员来说是非常便捷的工具。界面干净，用起来非常顺手，顶部的分支时间线非常绚丽。 1.2、Source tree老牌的Git GUI管理工具了，也号称是最好用的Git GUI工具。功能丰富，基本操作和高级操作都非常流畅，适合初学者上手。 1.3、TortoiseGit对于熟悉SVN的开发人员来说，这个小乌龟图标应该是非常友善了。TortoiseGit 简称 tgit, 中文名海龟Git。它与其前辈TortoiseSVN都是非常优秀的开源版本控制客户端软件。 2、忽略文件场景：在项目目录下有很多万年不变的文件目录，例如css、js、images等，或者还有一些目录即便有改动，我们也不想让其提交到远程仓库的文档，此时我们可以使用“忽略文件”机制来实现需求。 忽略文件需要新建一个名为==.gitignore==的文件，该文件用于声明忽略文件或不忽略文件的规则，规则对当前目录及其子目录生效。注意：该文件因为没有文件名，没办法直接在windows目录下直接创建，可以通过命令行Git Bash来touch创建。 常见规则写法有如下几种： 12341）&#x2F;mtk&#x2F; 过滤整个文件夹2）*.zip 过滤所有.zip文件3）&#x2F;mtk&#x2F;do.c 过滤某个具体文件4) !index.php 不过滤具体某个文件 在.gitignore文件中，以#开头都是注释。案例：①先在本地创建一个js目录以及目录中的js文件②依次提交本地和线上③创建.gitignore文件并编写文件中的规则④再次提交本地和线上⑤并观察本地和线上的仓库是否有新加的index.js文件由于我本地安装的工具是TortoiseGit，明显的看出来index.js文件是被忽略的文件。","tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://nonniexie.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","permalink":"https://nonniexie.github.io/tags/git/"}]},{"title":"awk文本分析工具","date":"2019-07-12T16:46:25.053Z","path":"article/20190713.html","text":"一、awk工具sed是以行为单位处理文件，awk比sed强的地方在于不仅可以使用行为单位也可以使用列为单位处理文件。awk缺省的行分隔符是换行，缺省的列分隔符是连续的空格和tab,但是行分隔和列分隔符都可以进行自定义。比如/etc/passwd文件的每一行有若干个字段，字段之间以:分隔，就可以重新定义awk的列分隔符为:并以列为单位处理这个文件。 awk的基本用法和sed类似，awk命令行的基本的形式： 12awk 参数 &#39;脚本语句(&#x2F;pattern&#x2F;&#123;actions&#125;)&#39; 待操作文件awk 参数 -f &#39;脚本文件&#39; 待操作文件 注意：printf不带换行，print带换行 例如： 123456awk &#39;&#123;print $0&#125;&#39; awk.sh #打印整个文件awk &#39;&#123;print $1&#125;&#39; awk.sh #打印每一行的的第一列awk &#39;&#x2F;^ *$&#x2F;&#123;count&#x3D;count+1&#125; END &#123;print count&#125;&#39; test.txt #统计一个文件中的空行ps aux | awk &#39;&#123;print $2&#125;&#39; #打印进程的PIDps aux | awk &#39;$2&gt;20000 &#123;print $2&#125;&#39; #打印PID大于20000的ps aux | awk &#39;$2&gt;2000 &amp;&amp; $2&lt;&#x3D;3000 &#123;count&#x3D;count+1&#125; END &#123;print count&#125;&#39; #统计PID大于2000小于3000的个数 awk常用的内建变量：| 变量| 变量说明||—|—||FILENAME|当前输入文件的文件名，该变量只读的||FILENAME|当前输入文件的文件名，该变量是只读的|NR |当前行的行号，该变量是只读的，R代表record|NF |当前行所拥有的列数，该变量是只读的，F代表field|OFS |输出格式的列分隔符，缺省是空格|FS |输入文件的列分融符，缺省是连续的空格和Tab|ORS |输出格式的行分隔符，缺省是换行符|RS |输入文件的行分隔符，缺省是换行符 例如打印系统中的用户账号列表： 12awk -F: &#39;&#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd #自定义:为分隔符，打印&#x2F;etc&#x2F;passwd的第一列 awk &#39;BEIN &#123;FS&#x3D;&quot;:&quot;&#125; &#123;print $1;&#125;&#39; &#x2F;etc&#x2F;passwd awk还可以想c语言一样使用if/else、while、for控制结构。可自行自行学习。","tags":[{"name":"shell","slug":"shell","permalink":"https://nonniexie.github.io/tags/shell/"}]},{"title":"sed流编译器","date":"2019-07-10T16:48:37.622Z","path":"article/20190711.html","text":"一、sed工具sed为流编译器，是对一个文档中的行数据进行处理。我们都知道，sed和vi都是早期的UNIX的工具，因此很多的sed命令和vi的末行命令都是非常相似的。 如果将test.sh中的echo替换为printf 可以使用vim编译器的末行模式输入:%s/echo/printf/g。而在命令模式输入uu来进行撤销。 也可以使用sed流编译器来进行修改。 sed命令的基本格式： 12sed 参数 &#96;&#39;脚本语句(&#x2F;pattern&#x2F;&#123;actions&#125;)&#39;&#96; 待操控文件 sed 参数 -f &#96;脚本文件&#96; 待操控的文件 有关sed的选项含义： 123456789101112--version 显示sed版本。--help 显示帮助文档。-n,--quiet,--silent 静默输出，默认情况下，sed程序在所有的脚本指令执行完毕后，将自动打印模式空间中的内容，这些选项可以屏蔽自动打印。-e script 允许多个脚本指令被执行。-f script-file,--file&#x3D;script-file 从文件中读取脚本指令，对编写自动脚本程序来说很棒！-i,--in-place 直接修改源文件，经过脚本指令处理后的内容将被输出至源文件（源文件被修改）慎用！-l N, --line-length&#x3D;N 该选项指定l指令可以输出的行长度，l指令用于输出非打印字符。--posix 禁用GNU sed扩展功能。-r, --regexp-extended 在脚本指令中使用扩展正则表达式-s, --separate 默认情况下，sed将把命令行指定的多个文件名作为一个长的连续的输入流。而GNU sed则允许把他们当作单独的文件，这样如正则表达式则不进行跨文件匹配。-u, --unbuffered 最低限度的缓存输入与输出。 上面的是sed本身选项功能说明，这里介绍几个常用简单的sed操作。 简称 原名 汉语意思 a append 追加 i insert 插入 d delete 删除 s substitution 替换 例如： 1234sed &#39;4a hello&#39; case.sh #在case.sh文件的第四行添加hellosed &#39;5d&#39; test.sh #删除test.sh的第五行数据sed &#39;2,5d&#39; test.sh #删除test.sh的第二行到第五行数据sed &#39;s&#x2F;echo&#x2F;printf&#x2F;g&#39; test.sh #将test.sh中的echo替换为printf 1.1、常用的sed命令sed的编辑命令可以直接当命令行参数传入，也可以写成一个脚本文件然后用-f参数指定，编辑命令的格式为：/pattern/action 说明：其中pattern是正则表达式，action是编辑操作。sed程序一行一行读出待处理文件，如果某一行与pattern匹配，则执行相应的action，如果一条命令没有pattern而只有action，这个action将作用于待处理文件的每一行。 1234&#x2F;pattern&#x2F;p #打印匹配pattern的行&#x2F;pattern&#x2F;d #删除匹配pattern的行&#x2F;pattern&#x2F;s&#x2F;pattern1&#x2F;pattern2&#x2F; #查找符合pattern的行，将该行第一个匹配pattern1的字符串替换为pattern2&#x2F;pattern&#x2F;s&#x2F;pattern1&#x2F;pattern2&#x2F;g #查找符合pattern的行，将该行所有匹配pattern1的字符串替换为pattern2 在使用p命令的时候，要注意p命令表示除了把文件内容打印出来之外还额外打印一遍匹配pattern的行。如果我们就想要输出结果，可以加上-n选项 12345sed &#39;&#x2F;echo&#x2F;p&#39; test.shsed &#39;&#x2F;echo&#x2F;d&#39; test.shsed &#39;&#x2F;echo&#x2F;echo~~&#x2F;&#39; test.shsed &#39;&#x2F;echo~~&#x2F;echo&#x2F;g&#39; test.shsed &#39;s&#x2F;&lt;.*&gt;&#x2F;&#x2F;g&#39; test.html #去掉所有的html标签","tags":[{"name":"shell","slug":"shell","permalink":"https://nonniexie.github.io/tags/shell/"}]},{"title":"Linux下静态库与动态库的制作","date":"2019-06-09T16:39:21.356Z","path":"article/20190610.html","text":"一、静态库的制作 命名规则 lib+库的名字+.a 例如：libmytest.a 制作步骤 2.1、.c文件生成对应的.o文件 gcc *.c -c 2.2、将生成的.o文件打包 ar rcs + 静态库的名字(libmytest.a) + 生成的所有的.o 发布和使用静态库 3.1、发布静态库(lib) 4.2、头文件(include) 用户的使用有下面两种使用方式： 12345gcc + 源文件 + 静态库文件 -o +可执行程序 -I头文件gcc main.c lib&#x2F;libtest.a -o sum -Iincludegcc + 源文件 -I头文件 -L 静态库的目录 + 库名 -o+ 可执行程序gcc main.c -Iinclude -L lib -l MyCalc -o app 查看静态库 nm+静态库 nm libMyCalc.anm+可执行程序 静态库的优缺点 优点： a、发布程序的时候。不需要提供对应的库 b、加载库的速度 缺点： a、库被打包到应用程序中，导致库的体积很大 b、库发生了变化，需要重新编译程序 实现过程过程： 二、动态库的制作 命名规则 lib+库的名字+.so (类似与Windows下的dll文件) 制作步骤 2.1、生成与位置无关的代码(生成与位置无关的.o) gcc -fPIC -c *.c -I../include 2.2、将.0打包成共享库(动态库) gcc -shared -o libMyCalc.so *.o -I../include 发布和使用静态库 3.1、发布静态库(lib) 4.2、头文件(include) 用户的使用方式有下面两种： 12345gcc + 源文件 + 动态库文件 -o +可执行程序 -I头文件gcc main.c lib&#x2F;libtest.so -o app -Iinclude &#x2F;&#x2F;运行.&#x2F;app,正确gcc + 源文件 -I头文件 -L 动态库的目录 + 库名 -o+ 可执行程序gcc main.c -Iinclude -L lib -l MyCalc -o app &#x2F;&#x2F;运行.&#x2F;app，错误无法找到动态链接库 解决动态库失败的问题 1)、放到库目录中（不推荐使用）将动态库cp(拷贝)到系统lib下sudo cp lib/libMyCalc.so /lib,可以通过ldd 可执行文件来查看这样存在缺点，如何你自己的动态库和系统的动态库一样这样不就是存在错误。不推荐使用 2)、临时设置配置LD_LIBRARY_PATH环境变量，将动态库的路径配置到环境变量中 1234echo $LD_LIBRARY_PATH &#x2F;&#x2F;打印环境变量export LD_LIBRARY_PATH&#x3D;相对路径export LD_LIBRARY_PATH&#x3D;.&#x2F;lib这样的设置是临时的.在终端关闭设置就会失效，在制作的过程中使用。 3)、不常用的方法（永久设置）修改家目录下.bashrc的配置文件的内容，在修改完成之后需要重启终端在最后一行添加：export LD_LIBRARY_PATH=绝对路径 LD_LIBRARY_PATH123- 4)、需要找到动态连接器的配置文件，将动态库的路径写到配置文件中，然后在进行更新已经显示操作使用命令&#96;sudo ldconfig -v&#96;&#96;&#96;&#96;sudo vim &#x2F;etc&#x2F;ld.so.conf 动态库的有点 优点： a、执行程序体积小 b、函数接口不变的情况下，动态库更新了，不需要编译程序 缺点： a、发布时需要将动态库提供给用户 b、动态库没有被打包到应用程序中，加载速度相对比较慢","tags":[{"name":"Linux","slug":"Linux","permalink":"https://nonniexie.github.io/tags/Linux/"}]},{"title":"VS 2017 使用C语言操作mysql数据库","date":"2019-05-19T16:38:10.073Z","path":"article/20190520.html","text":"一、在操作之间首先安装软件：1、Windows下安装MySQL数据库2、安装Visual Studio 2017 二、VS 2017环境配置 点击项目-&gt;项目属性，操作如图:2、选择C/C++,在常规的附加包含目录添加mysql安装地址中include文件的地址，如我的地址是C:\\Program Files\\MySQL\\MySQL Server 5.7\\include,如图： 选择链接器，在常规中附加目录中添加mysql安装地址lib文件的地址，如我的地址是C:\\Program Files\\MySQL\\MySQL Server 5.7\\lib,如图： 点击链接器中的输入，在附加依赖项中添加==libmysql.lib==，如图： 将mysql安装目录C:\\Program Files\\MySQL\\MySQL Server 5.7\\lib下的==libmysql.dll==复制到自己所建立的项目的同名文件夹下中,如图： 将运行的平台给为x64为，如图： 三、数据库操作代码 说明：这里我使用的是远程的数据库来进行连接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;mysql.h&gt;#include &lt;stdio.h&gt;int main()&#123; int res; MYSQL conn; //初始化MySQL连接句柄 mysql_init(&amp;conn); if (&amp;conn != NULL) &#123; printf(\"mysql句柄初始化成功\\n\"); &#125; else &#123; printf(\"Err in init\\n\"); return -1; &#125; //连接mysql数据库 if (mysql_real_connect (&amp;conn, //MySQL句柄 \"192.168.37.134\", //参数地址，本地数据库使用localhost \"root\", //数据库名 \"123456\", //数据库密码 \"db_test\", //数据库名 0, //数据库端口，0表示默认(即3306) NULL, //如果unix_socket不是NULL，字符串指定套接字或应该被使用的命名管道。注意host参数决定连接的类型 0)) //通常是0 &#123; printf(\"数据库连接成功\\n\"); &#125; else &#123; printf(\"数据库连接失败\\n\"); mysql_close(&amp;conn); //关闭连接 return -1; &#125; //数据的插入 res = mysql_query(&amp;conn, \"insert into testTB3 values(5,'aa')\"); //MySQL句柄 SQL语句 if (res == 0) &#123; printf(\"插入成功\\n\"); &#125; else &#123; printf(\"插入失败\\n\"); mysql_close(&amp;conn); return -1; &#125; //数据的删除 res = mysql_query(&amp;conn, \"delete from testTB3 where name='aa'\"); if (res == 0) &#123; printf(\"删除成功\\n\"); &#125; else &#123; printf(\"删除失败\\n\"); mysql_close(&amp;conn); return -1; &#125; //数据的查询 res = mysql_query(&amp;conn, \"select * from testTB3\"); if (res == 0) &#123; printf(\"查询成功\\n\"); &#125; else &#123; printf(\"查询失败\\n\"); mysql_close(&amp;conn); return -1; &#125; //解析查询结果 MYSQL_RES *res_ptr;//指向结果集索引的指针 res_ptr = mysql_store_result(&amp;conn);//检索完整的结果集当当前程序 if (res_ptr != NULL) &#123; //打印出结果集中一共有多少行记录 unsigned long Row = mysql_num_rows(res_ptr);//结果集中的行数 printf(\"有%lu行记录\\n\", Row); &#125; else &#123; printf(\"结果集操作保留出错\\n\"); mysql_close(&amp;conn); return -1; &#125; //取出字段名 MYSQL_FIELD *fd; int i = 0; while (fd = mysql_fetch_field(res_ptr)) &#123; printf(\"%s\\t\", fd-&gt;name); i++; &#125; putchar('\\n'); //取出所有内容 MYSQL_ROW sqlrow; int j; while (sqlrow = mysql_fetch_row(res_ptr)) &#123; //将每一行的内容分割成每一个记录 for (j = 0; j &lt; i; j++) &#123; printf(\"%s\\t\", sqlrow[j]); &#125; putchar('\\n'); &#125; //释放结果集索引所在内存 mysql_free_result(res_ptr); mysql_close(&amp;conn); return 0;&#125; 运行结果，如图所示：","tags":[{"name":"MySql","slug":"MySql","permalink":"https://nonniexie.github.io/tags/MySql/"}]},{"title":"Linux下的用户身份与文件权限","date":"2019-05-01T13:39:02.339Z","path":"article/20190501.html","text":"一、用户管理创建用户 sudo adduser + 用户名（luffy） sudo useradd -s /bin/bash -g itcast -d /home/itcast -m itcast -s 指定新用户登陆时shell类型 -g 指定所属组，该组必须已经存在 -d 用户家目录 -m 用户家目录不存在时，自动创建该目录 设置用户组 sudo groupadd itcast 删除用户 sudo deluser + 用户名（luffy） sudo userdel -r itcast 选项 -r 的作用是把用户的主目录一起删除 切换用户 su + 用户名（sanji） root用户 sudo su 设置密码 sudo passwd + 用户名（luffy） sudo passwd root sudo passwd 设置root密码 退出登录用户 exit","tags":[{"name":"Linux","slug":"Linux","permalink":"https://nonniexie.github.io/tags/Linux/"}]},{"title":"Linux下的搜索grep和打包压缩tar","date":"2019-04-19T16:37:08.575Z","path":"article/20190420.html","text":"一、文件的查找1. 按文件属性查找:1). 文件名:find + 查找的目录 + -name + “文件的名字” 12find ~ -name &quot;test.c&quot; find ~ -name &quot;*.c&quot; &#x2F;&#x2F;*通配符 ~表示家目录 &#x2F;home&#x2F;salt 2). 文件大小: find + 查找目录 + -size + +10k-size默认单位：512B–》0.5k–》一个扇区的大小 1234说明: +表示大于 -表示小于 k为小写 M为大写 find ~ -size +10k &#x2F;&#x2F;文件&gt;10k find ~ -size -10k &#x2F;&#x2F;文件&lt;10k find ~ -size +10K -size -100k &#x2F;&#x2F;10k&lt;文件&lt;100k 3). 文件类型: find + 查找目录 + -type + d/f/b/c/s/p/l 文件类型 符号 普通文件 - (在搜索是用f) 目录 d 链接符号 l 块设备 b 字符设备 c socket文件 s 管道 p(mkfifo创建管道) 4). 查找目录：find 目录 -maxdepth 层数 -type d depth 在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。 1find .&#x2F; -maxdepth 2 -type d &#x2F;&#x2F;查找当前路径下2层的目录 2. 按文件内容查找:grep -r “查找的内容” + 查找的路径 1grep -r &quot;stdio.h&quot; ~ &#x2F;&#x2F;在家目录下查找有stdio.h的文件 二、解压工具1、屌丝版12345671. gzip 文件名 撤销压缩使用：gunzip 文件名不打包压缩,不保留原文件,不压缩目录,将文件压缩为.gz格式2. bzip2 文件名保留原文件：bzip -k 文件名撤销压缩使用：bunzip2 文件名不打包压缩,不压缩目录,将文件压缩为.bz2格式 2、高富帅版1、tar不使用z/j,该命令只是将文件或者目录进行打包操作 1234567891011121314参数: c-- 创建 &gt;&gt;&gt;压缩 x-- 释放 &gt;&gt;&gt;解压缩 v-- 显示提示信息 --压缩解压缩 --可以对其进行省略 f-- 指定压缩文件的名字 z-- 使用屌丝版本gzip的方式进行文件压缩 --.gz j-- 使用吊丝版本bzip2的方式进行文件压缩 --.bz2压缩： tar zcvf 生成压缩文件的名字(xxx.tar.gz) 要压缩的文件或者目录 tar jcvf 生成压缩文件解压缩： tar jxvf 压缩的名字(解压到当前目录) tar jxvf 压缩包名字 -C 压缩的目录 2、rar必须自己手动安装sudo apt-get install rar 12345678参数： 压缩:a 解压缩:x压缩: rar a 压缩包名(不需要带.rar会自动补全的) 需要压缩的文件或者目录解压缩： rar x 压缩包文件名(xxx.rar) &#x2F;&#x2F;解压到当前目录下 rar x 压缩包文件名(xxx.rar) 目录(test) &#x2F;&#x2F;解压到指定的test目录下 3、zip必须自己手动安装sudo apt-get install zip 12345压缩: zip 压缩包的名字 压缩的文件或者目录解压缩： unzip 压缩包的名字 &#x2F;&#x2F;解压到当前目录下 unzip 压缩包的名字 -d 解压的路径 总结： 相同之处：tar/rar/zip 参数 生成的压缩文件的名字 压缩的文件或者目录 –压缩的时候的语法tar/rar/zip 参数 压缩包的名字 参数(rar没有参数) 解压缩目录 –解压语法 三、软件的安装1、在线安装apt-get安装12345sudo apt-get install update &#x2F;&#x2F;更新软件列表sudo apt-get insatll tree &#x2F;&#x2F;安装sudo apt-get remove tree &#x2F;&#x2F;卸载sudo apt-get clear &#x2F;&#x2F;清除软件的安装包 实际就是清除：&#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives目录下的.deb文件sudo apt-get install aptitude &#x2F;&#x2F;安装aptitude下载工具 aptitude安装1234sudo aptitude insatll tree &#x2F;&#x2F;安装sudo aptitude remove tree &#x2F;&#x2F;移除sudo apt-get install aptitude &#x2F;&#x2F;重新安装sudo aptitude show tree &#x2F;&#x2F;显示当前软件的状态 2、deb包安装12sudo dpkg -i xxx.deb &#x2F;&#x2F;安装sudo dpkg -r xxx &#x2F;&#x2F;卸载 3、源码安装这里我不常用，后期用到在进行补充。 有关Linux下的指令请参看：https://cloud.tencent.com/developer/article/1498762","tags":[{"name":"Linux","slug":"Linux","permalink":"https://nonniexie.github.io/tags/Linux/"}]},{"title":"最全的Linux基本指令","date":"2019-02-19T16:32:08.715Z","path":"article/20190220.html","text":"Linux下的命令一、查看帮助命令 man man查看帮助内容 二、常用系统工作命令 echo命令用于在终端上输出字符串或者变量提取的值 格式：echo [字符串|$变量] 12echo Linux.com &#x2F;&#x2F;输出Linux.comecho $SHELL &#x2F;&#x2F;输出 &#x2F;bin&#x2F;bash date命令用于在终端上显示及其设置系统的时间或者日期 格式：date [选项][+指定格式] 参数 作用 %t 跳格 %H 小时(24) %I 小时(12) %M 分钟 %S 秒 %j 今年的第几天 1234date &#x2F;&#x2F;查看当前的时间date &quot;+%Y-%m-%d %H:%M:%S&quot; &#x2F;&#x2F;2020-04-14 22:00:53date -s &quot;20200414 8:30:00&quot; &#x2F;&#x2F;以管理员的权限设置当前时间为2020年 04月 14日 星期二 22:03:00 CSTdate +%j &#x2F;&#x2F;查看今天是当年的第几天 reboot命令用于重启系统,在管理员权限下 格式reboot poweroff命令用于重启系统,在管理员权限下 格式poweroff wget命令用于在终端上下载网络文件 格式wget [参数] 下载地址 参数 作用 -b 后台下载模式 -p 下载到指定目录 -t 最大的连接次数 -c 断点续传 -p 下载界面上的所有资源 -r 递归下载 1wget http:&#x2F;&#x2F;www.linuxprobe.com&#x2F;docs&#x2F;LinuxProbe. pdf &#x2F;&#x2F;下载此书的PDF文档 PS命令用于查看系统中的进程状态 格式ps [参数] 参数 作用 -a 显示所有进程(包括其他用户的进程) -u 用户以及其他详细信息 -x 显示没有控制终端的进程 top命令用于动态地监视进程活动与系统负载等信息,相当于任务管理器 格式top pidof命令用于查询某一个指定服务器进程的PID 格式pidof [参数][服务器名称] 1pidof bash &#x2F;&#x2F;查看本地bash的PID kill命令用于终止某个指定PID的服务进程 格式为kill [参数][进程PID] 1kill 2873 &#x2F;&#x2F;强制停止bash服务 killall命令用于终止某指定名称的服务所对应的全部进程 格式为killall [参数][进程名称] 三、系统状态监测命令 ifconfig命令用于获取网站配置与网路状态等信息 格式ifconfig uname命令用于查看系统内核与系统版本等信息 格式uname -a uptime命令用于查看系统的负载状态,负载的状态越低越好，尽量不要超过1 格式uptime free命令用于查看系统中内存的使用情况 格式free -h who命令用于查看登录主机的用户终端信息 格式who last命令用于查看所有系统的登录记录 格式last history命令用来显示历史执行的命令 格式history 12history history -c &#x2F;&#x2F;清空历史记录 sosreport命令用于收集系统配置架构信息并输出诊断文档 格式sosreport 四、工作目录贴换命令 pwd命令用于显示用户当前所有的工作目录 格式pwd cd命令用户切换工作路径 格式cd [目录名] ls命令用显示目录文件中文件的信息 格式ls [选项][文件] -a 查看全部文件(包括隐藏文件) -l 查看文件的属性、大小等详细信息 -la 查看全部文件(包括隐藏文件)的属性、大小等详细信息 -ld 查看目录信息 五、文本文件编译命令 cat命令用于查看纯文本(内容比较小的) 格式为cat [选项][文件]cat -n mysql_init.c //-n 显示行号 more命令用来查询纯文本(内容比较多的) 格式为more [选项][文件]more mysql_init.c //注：最下面有百分比来提示阅读多少 head命令用于查看纯文本(前n行) 格式为head [选项][文件]head -n 10 mysql_init.c 查看文件中前10行 tail命令用于查看纯文本文档的后N行或持续刷新内容 格式为tail [选项][文件]。注：tail命令和head十分相似 tr命令用于替换文本文件中的字符 格式tr [原字符] [目标字符]将aa.txt文件中的字符a替换为Acat aa.txt | tr a A wc命令用于统计文本的行数、字数、字节数 格式wc [参数][文本] 参数 作用 -l 只显示行数 -w 只显示单词数 -c 只显示字节数 stat命令用于查看文件的具体存储信息和时间等信息 格式stat 文件名称 cu命令用于按”列”提取字符 格式cut [参数][文本]，使用-f参数来设置需要看的列数，-d来设置间隔符号，-f来设置需要看的行数cut -d: -f1 /etc/passwd //用来提取passwd下保存的用户信息 diff命令用于比较多文本的差异 格式diff [参数]文件 12diff --brief 文件1 文件2 &#x2F;&#x2F;来确定两个文件是否不同diff -c 文件1 文件2 &#x2F;&#x2F;-c来详细比较多文件的差异之处 六、文件目录管理命令 touch命令用于创建空白文件或设置文件的时间 格式touch [选项][文件] mkdir命令用于创建空白的目录 格式mkdir [选项]目录使用-p参数来进行递归创建具有嵌套层次关系的文件，例如： mkdir -p aa/bb/cc cp命令同于复制文件 格式cp [参数]源文件 目标文件 注意： 目标文件是目录，会把源文件复制到该目录下 目标文件也是普通文件，会询问是否要覆盖它 目标文件不存在，则执行正常复制操作 参数 作用 -p 保留原始文件的属性 -d 若对象为”链接文件”，则就保留”链接文件”的属性 -r 递归持续复制（常用目录） -i 如果目标文件存在则询问是否复制 -a 相当于-pdr(p、d、r为上述参数) mv命令用于剪切文件或者文件的重命名 格式mv [选项] 源文件 [目标文件|目标文件名] rm命令用于删除文件或目录 格式rm [选项] 文件rm -i 文件 //-i删除时提示内容rm -f 文件 //-f强制删除rm -r mul //-r删除目录 dd命令用于按照指定大小和个数的数据块来复制文件或者转换文件 格式dd [参数]Linux系统下有/ect/zero的设备文件,它不占系统存储空间，但是可以为我们提供无穷无尽的数据资源，同时它也就作为了dd的输出文件。 参数 作用 if 输入的文件名称 of 输出的文件名称 bs 设置每个”块”的大小 count 设置要复制”块”的个数 从/dec/zero设备文件中取一个大小为560M的数据块，然后并保存名为file文件。 1dd if&#x2F;ect&#x2F;zero of&#x3D;file count&#x3D;1 bs&#x3D;560M file命令用于查看文件的类型 格式file 文件名，例如:file aa.txt 七、打包压缩与搜索命令 tar压缩指令和find查找指定，请移步其他 Linux下的搜索和打包压缩命令","tags":[{"name":"Linux","slug":"Linux","permalink":"https://nonniexie.github.io/tags/Linux/"}]},{"title":"使用Hexo+Github搭建自己的个人博客","date":"2018-12-15T16:21:06.054Z","path":"article/20181216.html","text":"1、准备工作 1、创建一个GitHub账户 2、下载安装 Node.js (包含 npm) 3、安装Git 2、打开git bash命令行输入: 注:在任意位置打开git bash输入即可。 123456node -v //查看node.js的版本号npm -v //查看npm的版本号npm install -g cnpm --registry=https://registry.npm.taobao.org //安装cnpm淘宝源cnpm -v //查看版本号cnpm install -g hexo-cli //安装hexo博客框架hexo -v //查看hexo的版本号 3、新建本地博客文件夹Blog 注：在电脑上自己找一个位置，进行新建文件夹Blog。 12345hexo init //初始化博客cnpm install --save hexo-deployer-git //安装git部署插件hexo server //开启本地预览服务hexo generate //生成静态文件hexo deploy //部署到远程站点 在Blog目录下先进行初始化hexo init ,然后安装：cnpm install --save hexo-deployer-git 4、GitHub新建仓库打开https://github.com/new来创建自己的仓库。修改Bolg目录下的，_config.yml文件 注意：仓库的地址可以是使用https协议也可以使用ssh协议。区别在于使用https协议每次部署需要输入GitHub的账户名和密码密码。 这里我使用的HTTPS协议，接下来命令行输入：hexo d进行部署； 注意下来需要输入你的GitHub用户名和密码。更换自己喜欢的主题：git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake参看下面链接进行配置https://github.com/chaooo/hexo-theme-BlueLakehttps://blog.luuman.club/2015/12/27/GitHubHexo/","tags":[{"name":"hexo","slug":"hexo","permalink":"https://nonniexie.github.io/tags/hexo/"},{"name":"BlueLake","slug":"BlueLake","permalink":"https://nonniexie.github.io/tags/BlueLake/"}]}]
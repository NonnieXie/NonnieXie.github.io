[{"title":"一篇文章弄明白Wireshark抓包工具的用法","date":"2020-04-15T16:53:12.015Z","path":"article/20200416.html","text":"wireshark网络抓包工具Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。网络封包分析软件的功能可想像成 “电工技师使用电表来量测电流、电压、电阻” 的工作 - 只是将场景移植到网络上，并将电线替换成网络线。 wireshark的官方下载地址：https://www.wireshark.org/download.html wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，从而显示网络封包的详细信息。 Wireshark不能做wireshark不能够修改封包的内容或者发送封包，只能够只来查看封包。 wireshark开始进行抓包wireshark开始界面wiershark是用来捕捉电脑上的某一个网卡的网络包，而电脑上具有多个网卡的时候就需要进行从着多个网卡中选择，你需要的一个网卡。 wireshark窗口介绍WireShark 主要分为这几个界面 Display Filter(显示过滤器)， 用于过滤 Packet List Pane(封包列表)， 显示捕获到的封包， 有源地址和目标地址，端口号。 颜色不同，代表 Packet Details Pane(封包详细信息), 显示封包中的字段 Dissector Pane(16进制数据) Miscellanous(地址栏，杂项) wireshark显示过滤使用显示过滤的原因，在我们者初次使用wireshark时，将会产生大量的冗余数据，想想这么多的数据让我们在其中找到我们需要的部分，这样就显得非常的难。相对而言过滤器就会在大量的数据中能够让我们从中找到我们所需要的数据信息。过滤器有两种： 显示过滤器，就是主界面上那个，用于在捕获的记录中找到所需要的记录 捕获过滤器：用来过滤捕获的封 包，以避免捕获的太多记录。在捕获→捕获过滤器 过滤表达式的规则 协议过滤TCP 只显示TCP协议。 IP 过滤 12ip.src ==192.168.1.102 显示源地址为192.168.1.102ip.dst==192.168.1.102 目标地址为192.168.1.102 端口过滤 12tcp.port &#x3D;&#x3D; 80 端口为80的 tcp.srcport &#x3D;&#x3D; 80 只显示TCP协议的愿端口为80的。 Http模式过滤 12http.request.method&#x3D;&#x3D;&quot;GET&quot; 只显示HTTP GET方法的。request.method&#x3D;&#x3D;&quot;GET&quot; 只显示HTTP GET方法的。 逻辑运算符为 AND/ OR","tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://nonniexie.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"Git的安装与使用","date":"2019-07-19T16:45:07.193Z","path":"article/20190720.html","text":"说明：此文章是学习黑马程序员Git零基础入门到实战详解整理的笔记，主要是Windowns下Git的安装、基本使用、分支管理、版本回退、冲突解决、GUI工具的介绍、文件忽略机制等。如想在Linux平台下安装Git 查看通过https://blog.csdn.net/qq_43630810/article/details/104483007来进行安装。 一、Git基础Git是目前世界上最先进的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 1、谈谈Git与SVN的区别 Git是分布式的，svn是集中式的：这个是Git和其他非分布式的版本控制系统的，最主要的区别。 Git把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn、.git的文件中 Gitf分支和SVN的分支不同：分支在SVN中一点都不特别，其实它就是版本库中的另一个目录 Git没有一个全局的版本号，而SVN有：目前为止这是SVN相比Git缺少最大的一个特征 Git的内容完整性要优于SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。2、SVN的弊端与Git的好处 SVN弊端：1、中央服务器坏了，一切OVER2、所有的上传和下载都是基于文件传输方式完成的，速度会慢 git好处1、无需连网也能记录查看历史版本信息2、无需过多依赖中央仓库，每个人本地也有全部的信息向中央仓库传输内容依托的是文件流传输，速度比SVN块N倍 3、Git与GitHubGit的安装与GithHub账户的注册不做介绍。1 、两者区别Git(https://git-scm.com/)是一个分布式版本控制系统，简单的说其就是一个软件，用于记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的软件。 Github（https://www.github.com）是一个为用户提供Git服务的网站，简单说就是一个可以放代码的地方（不过可以放的当然不仅是代码）。Github除了提供管理Git的web界面外，还提供了订阅、关注、讨论组、在线编辑器等丰富的功能。Github被称之为全球最大的基友网站。 二、Git的使用过程1、本地仓库1.1、工作流程Git本地操作分为三个区域： 工作流程： 工作流程： 1.2、本地仓库操作什么是仓库呢？仓库又名版本库，英文名repository，我们可以简单理解成是一个目录，用于存放代码的，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除等操作Git都能跟踪到。 ①在安装好后首次使用我们需要进行全局配置在桌面空白处右键，点击“Git Bash Here” 已打开Git命令行窗口 123$ git config --global user.name \"用户名\"$ git config --global user.email \"邮箱地址\"$ git config --list 注意：配置完成后输入git config –global user.name和git config –global user.email进行查看，是否是自己所绑定的。 ②创建仓库当我们需要让Git去管理某个项目的时候，就需要创建仓库了。在创建仓库时使用的目录不一定要求是非空的目录，但是最好使用一个非空的目录。 注意：在使用过程中最好不要使用包含中文的目录名（目录亦是如此）。 a、创建空目录：mkdir pro_gitb、进入项目目录中：cd pro_gitc、Git仓库初始化：（让Git知道，它需要来管理这几个目录） 指令：git init③Git常用指令操作查看当前状态：git status 【非必要】添加到缓存区：git add 文件名 1234说明：git add指令，可以添加一个文件，也可以同时添加多个文件。语法1：git add 文件名语法2：git add 文件名1 文件名2 文件名3 …语法3：git add . 【添加当前目录到缓存区中】 提交至版本库：git commit -m “注释内容” 1.3、版本回退版本回退分为两步骤进行操作： 12345678步骤： ①查看版本，确定需要回到的时刻点 指令： git log git log --pretty=oneline ②回退操作 指令： git reset --hard 提交编号 案例：查看版本和回退到创建第一个文件readme.txt的版本。 注意:回退到过去的版本，要想在回到之间最新的版本的时候。可以通过之间查看的的提交码回到最新版本，也可以使用(git reflog)指令去查看历史操作，以得到最新的commit ID。 2、远程仓库主要以GitHub为例。 2.1、GithHub创建打开创建仓库页面：https://github.com/new圈出的部分为必填项，其余根据实际需要选择性补充： 注意：仓库名要在当前用户下唯一。 2.2 、两种不同的使用方式2.2.1、基于http/https协议a、创建空目录，名称为shopb、使用clone指令克隆线上仓库到本地语法：git clone 线上仓库 c、在仓库上做对应的操作（提交暂存区、提交本地仓库、提交线上仓库、拉取线上仓库）提交到线上仓库的指令：git push拉取线上仓库：git pull 提醒：在以后每天工作中第一件事就是先git pull拉取线上最新的版本；而下班前要做的是git push，将本地的代码提交到线上仓库。 2.2.2、基于ssh协议（推荐）该方式与前面https方式相比，此方式影响github对于用户的身份鉴权方式，对于git的具体操作（如提交本地、添加注释、提交远程等操作）没有任何影响。 ①生成公私玥对指令（需先OpenSSH安装，若是没有联系我）：ssh-keygen -t rsa -C “注册邮箱”②上传公钥内容（id_rsa.pub）③执行后续git的操作a、clone线上仓库到本地（git clone）b、修改文件后添加缓存区、提交本地仓库、提交线上仓库在git push的时候并没有提示要求我们输入帐号密码，说明公私玥已经实现了用户身份鉴权。 2.3、分支管理什么是分支？ 在版本回退中，每次提交后都会有记录，Git把它们串成时间线，形成类似于时间轴的东西，这个时间轴就是一个分支，我们称之为==master分支==。 而在开发的时候往往是团队协作，多人进行开发，因此光有一个分支是无法满足多人同时开发的需求的，并且在分支上工作并不影响其他分支的正常使用，会更加安全，Git鼓励开发者使用分支去完成一些开发任务。 123456分支相关指令：查看分支：git branch创建分支：git branch 分支名切换分支：git checkout 分支名 删除分支：git branch -d 分支名合并分支：git merge 被合并的分支名 查看分支： 注意：当前分支前面有个标记“*”； 创建分支：切换分支：合并分支：现在先将dev分支下的readme文件中添加一行并提交到本地切换到master分支下观察readme文件的内容将dev分支的内容和master分支合并：删除分支： 注意：在删除分支的时候，一定要先退出要删除的分支，然后才能删除。 合并所有分支之后，需要将master分支提交线上远程仓库中： 2.4、冲突的产生与解决案例：模拟产生冲突。①下班之后同事在线上仓库进行修改 注意：此时我的本地仓库的内容和线上不一致的。 ②第二天上班的时候，没有拉取线（git pull）上的文件，而直接修改了本地所对应的文件内容。③在下班的时候将文件推送到线上仓库（git push） 提示我们要在再次push之间先git pull操作。 ==【解决冲突】==④先git pull⑤打开冲突文件，解决冲突解决方法：需要和同事进行商量，看代码如何保留，然后将改好的文件再次提交即可。⑥重新提交⑦查看线上效果 新手小技巧：上班第一件事先git pull,可以在一定程度上避免冲突的产生。 三、实用技能1、图形管理工具1.1、GitHub for DektopGithub出品的软件，功能完善，使用方便。对于经常使用GitHub的开发人员来说是非常便捷的工具。界面干净，用起来非常顺手，顶部的分支时间线非常绚丽。 1.2、Source tree老牌的Git GUI管理工具了，也号称是最好用的Git GUI工具。功能丰富，基本操作和高级操作都非常流畅，适合初学者上手。 1.3、TortoiseGit对于熟悉SVN的开发人员来说，这个小乌龟图标应该是非常友善了。TortoiseGit 简称 tgit, 中文名海龟Git。它与其前辈TortoiseSVN都是非常优秀的开源版本控制客户端软件。 2、忽略文件场景：在项目目录下有很多万年不变的文件目录，例如css、js、images等，或者还有一些目录即便有改动，我们也不想让其提交到远程仓库的文档，此时我们可以使用“忽略文件”机制来实现需求。 忽略文件需要新建一个名为==.gitignore==的文件，该文件用于声明忽略文件或不忽略文件的规则，规则对当前目录及其子目录生效。注意：该文件因为没有文件名，没办法直接在windows目录下直接创建，可以通过命令行Git Bash来touch创建。 常见规则写法有如下几种： 12341）&#x2F;mtk&#x2F; 过滤整个文件夹2）*.zip 过滤所有.zip文件3）&#x2F;mtk&#x2F;do.c 过滤某个具体文件4) !index.php 不过滤具体某个文件 在.gitignore文件中，以#开头都是注释。案例：①先在本地创建一个js目录以及目录中的js文件②依次提交本地和线上③创建.gitignore文件并编写文件中的规则④再次提交本地和线上⑤并观察本地和线上的仓库是否有新加的index.js文件由于我本地安装的工具是TortoiseGit，明显的看出来index.js文件是被忽略的文件。","tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://nonniexie.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","permalink":"https://nonniexie.github.io/tags/git/"}]},{"title":"Linux下静态库和动态库的制作","date":"2019-06-09T16:39:21.356Z","path":"article/20190610.html","text":"@[toc] 一、静态库的制作 命名规则 lib+库的名字+.a 例如：libmytest.a 制作步骤 2.1、.c文件生成对应的.o文件 gcc *.c -c 2.2、将生成的.o文件打包 ar rcs + 静态库的名字(libmytest.a) + 生成的所有的.o 发布和使用静态库 3.1、发布静态库(lib) 4.2、头文件(include) 用户的使用有下面两种使用方式： 12345gcc + 源文件 + 静态库文件 -o +可执行程序 -I头文件gcc main.c lib&#x2F;libtest.a -o sum -Iincludegcc + 源文件 -I头文件 -L 静态库的目录 + 库名 -o+ 可执行程序gcc main.c -Iinclude -L lib -l MyCalc -o app 查看静态库 nm+静态库 nm libMyCalc.anm+可执行程序 静态库的优缺点 优点： a、发布程序的时候。不需要提供对应的库 b、加载库的速度 缺点： a、库被打包到应用程序中，导致库的体积很大 b、库发生了变化，需要重新编译程序 实现过程过程： 二、动态库的制作 命名规则 lib+库的名字+.so (类似与Windows下的dll文件) 制作步骤 2.1、生成与位置无关的代码(生成与位置无关的.o) gcc -fPIC -c *.c -I../include 2.2、将.0打包成共享库(动态库) gcc -shared -o libMyCalc.so *.o -I../include 发布和使用静态库 3.1、发布静态库(lib) 4.2、头文件(include) 用户的使用方式有下面两种： 12345gcc + 源文件 + 动态库文件 -o +可执行程序 -I头文件gcc main.c lib&#x2F;libtest.so -o app -Iinclude &#x2F;&#x2F;运行.&#x2F;app,正确gcc + 源文件 -I头文件 -L 动态库的目录 + 库名 -o+ 可执行程序gcc main.c -Iinclude -L lib -l MyCalc -o app &#x2F;&#x2F;运行.&#x2F;app，错误无法找到动态链接库 解决动态库失败的问题 1)、放到库目录中（不推荐使用）将动态库cp(拷贝)到系统lib下sudo cp lib/libMyCalc.so /lib,可以通过ldd 可执行文件来查看这样存在缺点，如何你自己的动态库和系统的动态库一样这样不就是存在错误。不推荐使用 2)、临时设置配置LD_LIBRARY_PATH环境变量，将动态库的路径配置到环境变量中 1234echo $LD_LIBRARY_PATH &#x2F;&#x2F;打印环境变量export LD_LIBRARY_PATH&#x3D;相对路径export LD_LIBRARY_PATH&#x3D;.&#x2F;lib这样的设置是临时的.在终端关闭设置就会失效，在制作的过程中使用。 3)、不常用的方法（永久设置）修改家目录下.bashrc的配置文件的内容，在修改完成之后需要重启终端在最后一行添加：export LD_LIBRARY_PATH=绝对路径 LD_LIBRARY_PATH123- 4)、需要找到动态连接器的配置文件，将动态库的路径写到配置文件中，然后在进行更新已经显示操作使用命令&#96;sudo ldconfig -v&#96;&#96;&#96;&#96;sudo vim &#x2F;etc&#x2F;ld.so.conf 动态库的有点 优点： a、执行程序体积小 b、函数接口不变的情况下，动态库更新了，不需要编译程序 缺点： a、发布时需要将动态库提供给用户 b、动态库没有被打包到应用程序中，加载速度相对比较慢","tags":[]},{"title":"VS 2017 使用C语言操作mysql数据库","date":"2019-05-19T16:38:10.073Z","path":"article/20190520.html","text":"一、在操作之间首先安装软件：1、Windows下安装MySQL数据库2、安装Visual Studio 2017 二、VS 2017环境配置 点击项目-&gt;项目属性，操作如图:2、选择C/C++,在常规的附加包含目录添加mysql安装地址中include文件的地址，如我的地址是C:\\Program Files\\MySQL\\MySQL Server 5.7\\include,如图： 选择链接器，在常规中附加目录中添加mysql安装地址lib文件的地址，如我的地址是C:\\Program Files\\MySQL\\MySQL Server 5.7\\lib,如图： 点击链接器中的输入，在附加依赖项中添加==libmysql.lib==，如图： 将mysql安装目录C:\\Program Files\\MySQL\\MySQL Server 5.7\\lib下的==libmysql.dll==复制到自己所建立的项目的同名文件夹下中,如图： 将运行的平台给为x64为，如图： 三、数据库操作代码 说明：这里我使用的是远程的数据库来进行连接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;mysql.h&gt;#include &lt;stdio.h&gt;int main()&#123; int res; MYSQL conn; //初始化MySQL连接句柄 mysql_init(&amp;conn); if (&amp;conn != NULL) &#123; printf(\"mysql句柄初始化成功\\n\"); &#125; else &#123; printf(\"Err in init\\n\"); return -1; &#125; //连接mysql数据库 if (mysql_real_connect (&amp;conn, //MySQL句柄 \"192.168.37.134\", //参数地址，本地数据库使用localhost \"root\", //数据库名 \"123456\", //数据库密码 \"db_test\", //数据库名 0, //数据库端口，0表示默认(即3306) NULL, //如果unix_socket不是NULL，字符串指定套接字或应该被使用的命名管道。注意host参数决定连接的类型 0)) //通常是0 &#123; printf(\"数据库连接成功\\n\"); &#125; else &#123; printf(\"数据库连接失败\\n\"); mysql_close(&amp;conn); //关闭连接 return -1; &#125; //数据的插入 res = mysql_query(&amp;conn, \"insert into testTB3 values(5,'aa')\"); //MySQL句柄 SQL语句 if (res == 0) &#123; printf(\"插入成功\\n\"); &#125; else &#123; printf(\"插入失败\\n\"); mysql_close(&amp;conn); return -1; &#125; //数据的删除 res = mysql_query(&amp;conn, \"delete from testTB3 where name='aa'\"); if (res == 0) &#123; printf(\"删除成功\\n\"); &#125; else &#123; printf(\"删除失败\\n\"); mysql_close(&amp;conn); return -1; &#125; //数据的查询 res = mysql_query(&amp;conn, \"select * from testTB3\"); if (res == 0) &#123; printf(\"查询成功\\n\"); &#125; else &#123; printf(\"查询失败\\n\"); mysql_close(&amp;conn); return -1; &#125; //解析查询结果 MYSQL_RES *res_ptr;//指向结果集索引的指针 res_ptr = mysql_store_result(&amp;conn);//检索完整的结果集当当前程序 if (res_ptr != NULL) &#123; //打印出结果集中一共有多少行记录 unsigned long Row = mysql_num_rows(res_ptr);//结果集中的行数 printf(\"有%lu行记录\\n\", Row); &#125; else &#123; printf(\"结果集操作保留出错\\n\"); mysql_close(&amp;conn); return -1; &#125; //取出字段名 MYSQL_FIELD *fd; int i = 0; while (fd = mysql_fetch_field(res_ptr)) &#123; printf(\"%s\\t\", fd-&gt;name); i++; &#125; putchar('\\n'); //取出所有内容 MYSQL_ROW sqlrow; int j; while (sqlrow = mysql_fetch_row(res_ptr)) &#123; //将每一行的内容分割成每一个记录 for (j = 0; j &lt; i; j++) &#123; printf(\"%s\\t\", sqlrow[j]); &#125; putchar('\\n'); &#125; //释放结果集索引所在内存 mysql_free_result(res_ptr); mysql_close(&amp;conn); return 0;&#125; 运行结果，如图所示：","tags":[{"name":"MySql","slug":"MySql","permalink":"https://nonniexie.github.io/tags/MySql/"}]},{"title":"Linux下的用户身份与文件权限","date":"2019-05-01T13:39:02.339Z","path":"article/20190501.html","text":"一、用户管理创建用户 sudo adduser + 用户名（luffy） sudo useradd -s /bin/bash -g itcast -d /home/itcast -m itcast -s 指定新用户登陆时shell类型 -g 指定所属组，该组必须已经存在 -d 用户家目录 -m 用户家目录不存在时，自动创建该目录 设置用户组 sudo groupadd itcast 删除用户 sudo deluser + 用户名（luffy） sudo userdel -r itcast 选项 -r 的作用是把用户的主目录一起删除 切换用户 su + 用户名（sanji） root用户 sudo su 设置密码 sudo passwd + 用户名（luffy） sudo passwd root sudo passwd 设置root密码 退出登录用户 exit","tags":[{"name":"Linux","slug":"Linux","permalink":"https://nonniexie.github.io/tags/Linux/"}]},{"title":"Linux下的搜索和打包压缩命令","date":"2019-04-19T16:37:08.575Z","path":"article/20190420.html","text":"一、文件的查找1. 按文件属性查找:1). 文件名:find + 查找的目录 + -name + “文件的名字” 12find ~ -name &quot;test.c&quot; find ~ -name &quot;*.c&quot; &#x2F;&#x2F;*通配符 ~表示家目录 &#x2F;home&#x2F;salt 2). 文件大小: find + 查找目录 + -size + +10k 1234说明: +表示大于 -表示小于 k为小写 M为大写 find ~ -size +10k &#x2F;&#x2F;文件&gt;10k find ~ -size -10k &#x2F;&#x2F;文件&lt;10k find ~ -size +10K -size -100k &#x2F;&#x2F;10k&lt;文件&lt;100k 3). 文件类型: find + 查找目录 + -type + d/f/b/c/s/p/l 文件类型 符号 普通文件 - (在搜索是用f) 目录 d 链接符号 l 块设备 b 字符设备 c socket文件 s 管道 p(mkfifo创建管道) 2. 按文件内容查找:grep -r “查找的内容” + 查找的路径 1grep -r &quot;stdio.h&quot; ~ &#x2F;&#x2F;在家目录下查找有stdio.h的文件 二、解压工具1、屌丝版12345671. gzip 文件名 撤销压缩使用：gunzip 文件名不打包压缩,不保留原文件,不压缩目录,将文件压缩为.gz格式2. bzip2 文件名保留原文件：bzip -k 文件名撤销压缩使用：bunzip2 文件名不打包压缩,不压缩目录,将文件压缩为.bz2格式 2、高富帅版1、tar不使用z/j,该命令只是将文件或者目录进行打包操作 1234567891011121314参数: c-- 创建 &gt;&gt;&gt;压缩 x-- 释放 &gt;&gt;&gt;解压缩 v-- 显示提示信息 --压缩解压缩 --可以对其进行省略 f-- 指定压缩文件的名字 z-- 使用屌丝版本gzip的方式进行文件压缩 --.gz j-- 使用吊丝版本bzip2的方式进行文件压缩 --.bz2压缩： tar zcvf 生成压缩文件的名字(xxx.tar.gz) 要压缩的文件或者目录 tar jcvf 生成压缩文件解压缩： tar jxvf 压缩的名字(解压到当前目录) tar jxvf 压缩包名字 -C 压缩的目录 2、rar必须自己手动安装sudo apt-get install rar 12345678参数： 压缩:a 解压缩:x压缩: rar a 压缩包名(不需要带.rar会自动补全的) 需要压缩的文件或者目录解压缩： rar x 压缩包文件名(xxx.rar) &#x2F;&#x2F;解压到当前目录下 rar x 压缩包文件名(xxx.rar) 目录(test) &#x2F;&#x2F;解压到指定的test目录下 3、zip必须自己手动安装sudo apt-get install zip 12345压缩: zip 压缩包的名字 压缩的文件或者目录解压缩： unzip 压缩包的名字 &#x2F;&#x2F;解压到当前目录下 unzip 压缩包的名字 -d 解压的路径 总结： 相同之处：tar/rar/zip 参数 生成的压缩文件的名字 压缩的文件或者目录 –压缩的时候的语法tar/rar/zip 参数 压缩包的名字 参数(rar没有参数) 解压缩目录 –解压语法 三、软件的安装1、在线安装apt-get安装12345sudo apt-get install update &#x2F;&#x2F;更新软件列表sudo apt-get insatll tree &#x2F;&#x2F;安装sudo apt-get remove tree &#x2F;&#x2F;卸载sudo apt-get clear &#x2F;&#x2F;清除软件的安装包 实际就是清除：&#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives目录下的.deb文件sudo apt-get install aptitude &#x2F;&#x2F;安装aptitude下载工具 aptitude安装1234sudo aptitude insatll tree &#x2F;&#x2F;安装sudo aptitude remove tree &#x2F;&#x2F;移除sudo apt-get install aptitude &#x2F;&#x2F;重新安装sudo aptitude show tree &#x2F;&#x2F;显示当前软件的状态 2、deb包安装12sudo dpkg -i xxx.deb &#x2F;&#x2F;安装sudo dpkg -r xxx &#x2F;&#x2F;卸载 3、源码安装这里我不常用，后期用到在进行补充。 有关Linux下的指令请参看：https://cloud.tencent.com/developer/article/1498762","tags":[{"name":"Linux","slug":"Linux","permalink":"https://nonniexie.github.io/tags/Linux/"}]},{"title":"最全的Linux基本指令","date":"2019-02-19T16:32:08.715Z","path":"article/20190220.html","text":"Linux下的命令一、查看帮助命令 man man查看帮助内容 二、常用系统工作命令 echo命令用于在终端上输出字符串或者变量提取的值 格式：echo [字符串|$变量] 12echo Linux.com &#x2F;&#x2F;输出Linux.comecho $SHELL &#x2F;&#x2F;输出 &#x2F;bin&#x2F;bash date命令用于在终端上显示及其设置系统的时间或者日期 格式：date [选项][+指定格式] 参数 作用 %t 跳格 %H 小时(24) %I 小时(12) %M 分钟 %S 秒 %j 今年的第几天 1234date &#x2F;&#x2F;查看当前的时间date &quot;+%Y-%m-%d %H:%M:%S&quot; &#x2F;&#x2F;2020-04-14 22:00:53date -s &quot;20200414 8:30:00&quot; &#x2F;&#x2F;以管理员的权限设置当前时间为2020年 04月 14日 星期二 22:03:00 CSTdate +%j &#x2F;&#x2F;查看今天是当年的第几天 reboot命令用于重启系统,在管理员权限下 格式reboot poweroff命令用于重启系统,在管理员权限下 格式poweroff wget命令用于在终端上下载网络文件 格式wget [参数] 下载地址 参数 作用 -b 后台下载模式 -p 下载到指定目录 -t 最大的连接次数 -c 断点续传 -p 下载界面上的所有资源 -r 递归下载 1wget http:&#x2F;&#x2F;www.linuxprobe.com&#x2F;docs&#x2F;LinuxProbe. pdf &#x2F;&#x2F;下载此书的PDF文档 PS命令用于查看系统中的进程状态 格式ps [参数] 参数 作用 -a 显示所有进程(包括其他用户的进程) -u 用户以及其他详细信息 -x 显示没有控制终端的进程 top命令用于动态地监视进程活动与系统负载等信息,相当于任务管理器 格式top pidof命令用于查询某一个指定服务器进程的PID 格式pidof [参数][服务器名称] 1pidof bash &#x2F;&#x2F;查看本地bash的PID kill命令用于终止某个指定PID的服务进程 格式为kill [参数][进程PID] 1kill 2873 &#x2F;&#x2F;强制停止bash服务 killall命令用于终止某指定名称的服务所对应的全部进程 格式为killall [参数][进程名称] 三、系统状态监测命令 ifconfig命令用于获取网站配置与网路状态等信息 格式ifconfig uname命令用于查看系统内核与系统版本等信息 格式uname -a uptime命令用于查看系统的负载状态,负载的状态越低越好，尽量不要超过1 格式uptime free命令用于查看系统中内存的使用情况 格式free -h who命令用于查看登录主机的用户终端信息 格式who last命令用于查看所有系统的登录记录 格式last history命令用来显示历史执行的命令 格式history 12history history -c &#x2F;&#x2F;清空历史记录 sosreport命令用于收集系统配置架构信息并输出诊断文档 格式sosreport 四、工作目录贴换命令 pwd命令用于显示用户当前所有的工作目录 格式pwd cd命令用户切换工作路径 格式cd [目录名] ls命令用显示目录文件中文件的信息 格式ls [选项][文件] -a 查看全部文件(包括隐藏文件) -l 查看文件的属性、大小等详细信息 -la 查看全部文件(包括隐藏文件)的属性、大小等详细信息 -ld 查看目录信息 五、文本文件编译命令 cat命令用于查看纯文本(内容比较小的) 格式为cat [选项][文件]cat -n mysql_init.c //-n 显示行号 more命令用来查询纯文本(内容比较多的) 格式为more [选项][文件]more mysql_init.c //注：最下面有百分比来提示阅读多少 head命令用于查看纯文本(前n行) 格式为head [选项][文件]head -n 10 mysql_init.c 查看文件中前10行 tail命令用于查看纯文本文档的后N行或持续刷新内容 格式为tail [选项][文件]。注：tail命令和head十分相似 tr命令用于替换文本文件中的字符 格式tr [原字符] [目标字符]将aa.txt文件中的字符a替换为Acat aa.txt | tr a A wc命令用于统计文本的行数、字数、字节数 格式wc [参数][文本] 参数 作用 -l 只显示行数 -w 只显示单词数 -c 只显示字节数 stat命令用于查看文件的具体存储信息和时间等信息 格式stat 文件名称 cu命令用于按”列”提取字符 格式cut [参数][文本]，使用-f参数来设置需要看的列数，-d来设置间隔符号，-f来设置需要看的行数cut -d: -f1 /etc/passwd //用来提取passwd下保存的用户信息 diff命令用于比较多文本的差异 格式diff [参数]文件 12diff --brief 文件1 文件2 &#x2F;&#x2F;来确定两个文件是否不同diff -c 文件1 文件2 &#x2F;&#x2F;-c来详细比较多文件的差异之处 六、文件目录管理命令 touch命令用于创建空白文件或设置文件的时间 格式touch [选项][文件] mkdir命令用于创建空白的目录 格式mkdir [选项]目录使用-p参数来进行递归创建具有嵌套层次关系的文件，例如： mkdir -p aa/bb/cc cp命令同于复制文件 格式cp [参数]源文件 目标文件 注意： 目标文件是目录，会把源文件复制到该目录下 目标文件也是普通文件，会询问是否要覆盖它 目标文件不存在，则执行正常复制操作 参数 作用 -p 保留原始文件的属性 -d 若对象为”链接文件”，则就保留”链接文件”的属性 -r 递归持续复制（常用目录） -i 如果目标文件存在则询问是否复制 -a 相当于-pdr(p、d、r为上述参数) mv命令用于剪切文件或者文件的重命名 格式mv [选项] 源文件 [目标文件|目标文件名] rm命令用于删除文件或目录 格式rm [选项] 文件rm -i 文件 //-i删除时提示内容rm -f 文件 //-f强制删除rm -r mul //-r删除目录 dd命令用于按照指定大小和个数的数据块来复制文件或者转换文件 格式dd [参数]Linux系统下有/ect/zero的设备文件,它不占系统存储空间，但是可以为我们提供无穷无尽的数据资源，同时它也就作为了dd的输出文件。 参数 作用 if 输入的文件名称 of 输出的文件名称 bs 设置每个”块”的大小 count 设置要复制”块”的个数 从/dec/zero设备文件中取一个大小为560M的数据块，然后并保存名为file文件。 1dd if&#x2F;ect&#x2F;zero of&#x3D;file count&#x3D;1 bs&#x3D;560M file命令用于查看文件的类型 格式file 文件名，例如:file aa.txt 七、打包压缩与搜索命令 tar压缩指令和find查找指定，请移步其他 Linux下的搜索和打包压缩命令","tags":[{"name":"Linux","slug":"Linux","permalink":"https://nonniexie.github.io/tags/Linux/"}]},{"title":"使用Hexo+Github搭建自己的个人博客","date":"2018-12-15T16:21:06.054Z","path":"article/20181216.html","text":"1、准备工作 1、创建一个GitHub账户 2、下载安装 Node.js (包含 npm) 3、安装Git 2、打开git bash命令行输入: 注:在任意位置打开git bash输入即可。 123456node -v //查看node.js的版本号npm -v //查看npm的版本号npm install -g cnpm --registry=https://registry.npm.taobao.org //安装cnpm淘宝源cnpm -v //查看版本号cnpm install -g hexo-cli //安装hexo博客框架hexo -v //查看hexo的版本号 3、新建本地博客文件夹Blog 注：在电脑上自己找一个位置，进行新建文件夹Blog。 12345hexo init //初始化博客cnpm install --save hexo-deployer-git //安装git部署插件hexo server //开启本地预览服务hexo generate //生成静态文件hexo deploy //部署到远程站点 在Blog目录下先进行初始化hexo init ,然后安装：cnpm install --save hexo-deployer-git 4、GitHub新建仓库打开https://github.com/new来创建自己的仓库。修改Bolg目录下的，_config.yml文件 注意：仓库的地址可以是使用https协议也可以使用ssh协议。区别在于使用https协议每次部署需要输入GitHub的账户名和密码密码。 这里我使用的HTTPS协议，接下来命令行输入：hexo d进行部署； 注意下来需要输入你的GitHub用户名和密码。更换自己喜欢的主题：git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake参看下面链接进行配置https://github.com/chaooo/hexo-theme-BlueLakehttps://blog.luuman.club/2015/12/27/GitHubHexo/","tags":[{"name":"hexo","slug":"hexo","permalink":"https://nonniexie.github.io/tags/hexo/"},{"name":"BlueLake","slug":"BlueLake","permalink":"https://nonniexie.github.io/tags/BlueLake/"}]}]